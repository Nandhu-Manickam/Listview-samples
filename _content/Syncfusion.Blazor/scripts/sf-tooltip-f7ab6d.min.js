(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["sf-tooltip"],{

/***/ "./bundles/sf-tooltip.js":
/*!*******************************!*\
  !*** ./bundles/sf-tooltip.js ***!
  \*******************************/
/*! no exports provided */
/*! all exports used */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _modules_sf_tooltip_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modules/sf-tooltip.js */ "./modules/sf-tooltip.js");


/***/ }),

/***/ "./modules/sf-tooltip.js":
/*!*******************************!*\
  !*** ./modules/sf-tooltip.js ***!
  \*******************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "../node_modules/@babel/runtime/helpers/typeof.js");
/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__);

window.sfBlazor = window.sfBlazor || {};

window.sfBlazor.Tooltip = function () {
  'use strict';
  /**
   * Position library
   */

  var elementRect;
  var popupRect;
  var element;
  var parentDocument;
  var fixedParent = false;

  function calculateRelativeBasedPosition(anchor, element) {
    var fixedElement = false;
    var anchorPos = {
      left: 0,
      top: 0
    };
    var tempAnchor = anchor;

    if (!anchor || !element) {
      return anchorPos;
    }

    if (sf.base.isNullOrUndefined(element.offsetParent) && element.style.position === 'fixed') {
      fixedElement = true;
    }

    while ((element.offsetParent || fixedElement) && anchor && element.offsetParent !== anchor) {
      anchorPos.left += anchor.offsetLeft;
      anchorPos.top += anchor.offsetTop;
      anchor = anchor.offsetParent;
    }

    anchor = tempAnchor;

    while ((element.offsetParent || fixedElement) && anchor && element.offsetParent !== anchor) {
      anchorPos.left -= anchor.scrollLeft;
      anchorPos.top -= anchor.scrollTop;
      anchor = anchor.parentElement;
    }

    return anchorPos;
  }

  function calculatePosition(currentElement, positionX, positionY, parentElement, targetValues) {
    positionY + positionX === 'topright' ? popupRect = undefined : popupRect = targetValues;
    popupRect = targetValues;
    fixedParent = parentElement ? true : false;

    if (!currentElement) {
      return {
        left: 0,
        top: 0
      };
    }

    if (!positionX) {
      positionX = 'left';
    }

    if (!positionY) {
      positionY = 'top';
    }

    parentDocument = currentElement.ownerDocument;
    element = currentElement;
    var pos = {
      left: 0,
      top: 0
    };
    return updatePosition(positionX.toLowerCase(), positionY.toLowerCase(), pos);
  }

  function setPosx(value, pos) {
    pos.left = value;
  }

  function setPosy(value, pos) {
    pos.top = value;
  }

  function updatePosition(posX, posY, pos) {
    elementRect = element.getBoundingClientRect();

    switch (posY + posX) {
      case 'topcenter':
        setPosx(getElementHCenter(), pos);
        setPosy(getElementTop(), pos);
        break;

      case 'topright':
        setPosx(getElementRight(), pos);
        setPosy(getElementTop(), pos);
        break;

      case 'centercenter':
        setPosx(getElementHCenter(), pos);
        setPosy(getElementVCenter(), pos);
        break;

      case 'centerright':
        setPosx(getElementRight(), pos);
        setPosy(getElementVCenter(), pos);
        break;

      case 'centerleft':
        setPosx(getElementLeft(), pos);
        setPosy(getElementVCenter(), pos);
        break;

      case 'bottomcenter':
        setPosx(getElementHCenter(), pos);
        setPosy(getElementBottom(), pos);
        break;

      case 'bottomright':
        setPosx(getElementRight(), pos);
        setPosy(getElementBottom(), pos);
        break;

      case 'bottomleft':
        setPosx(getElementLeft(), pos);
        setPosy(getElementBottom(), pos);
        break;

      default:
      case 'topleft':
        setPosx(getElementLeft(), pos);
        setPosy(getElementTop(), pos);
        break;
    }

    return pos;
  }

  function getBodyScrollTop() {
    return parentDocument.documentElement.scrollTop || parentDocument.body.scrollTop;
  }

  function getBodyScrollLeft() {
    return parentDocument.documentElement.scrollLeft || parentDocument.body.scrollLeft;
  }

  function getElementBottom() {
    return fixedParent ? elementRect.bottom : elementRect.bottom + getBodyScrollTop();
  }

  function getElementVCenter() {
    return getElementTop() + elementRect.height / 2;
  }

  function getElementTop() {
    return fixedParent ? elementRect.top : elementRect.top + getBodyScrollTop();
  }

  function getElementLeft() {
    return elementRect.left + getBodyScrollLeft();
  }

  function getElementRight() {
    return elementRect.right + getBodyScrollLeft() - (popupRect ? popupRect.width : 0);
  }

  function getElementHCenter() {
    return getElementLeft() + elementRect.width / 2;
  }
  /**
   * Collision module.
   */


  var parentDocument$1;
  var targetContainer;

  function fit(element, viewPortElement, axis, position) {
    if (viewPortElement === void 0) {
      viewPortElement = null;
    }

    if (axis === void 0) {
      axis = {
        X: false,
        Y: false
      };
    }

    if (!axis.Y && !axis.X) {
      return {
        left: 0,
        top: 0
      };
    }

    var elemData = element.getBoundingClientRect();
    targetContainer = viewPortElement;
    parentDocument$1 = element.ownerDocument;

    if (!position) {
      position = calculatePosition(element, 'left', 'top');
    }

    if (axis.X) {
      var containerWidth = targetContainer ? getTargetContainerWidth() : getViewPortWidth();
      var containerLeft = ContainerLeft();
      var containerRight = ContainerRight();
      var overLeft = containerLeft - position.left;
      var overRight = position.left + elemData.width - containerRight;

      if (elemData.width > containerWidth) {
        if (overLeft > 0 && overRight <= 0) {
          position.left = containerRight - elemData.width;
        } else if (overRight > 0 && overLeft <= 0) {
          position.left = containerLeft;
        } else {
          position.left = overLeft > overRight ? containerRight - elemData.width : containerLeft;
        }
      } else if (overLeft > 0) {
        position.left += overLeft;
      } else if (overRight > 0) {
        position.left -= overRight;
      }
    }

    if (axis.Y) {
      var containerHeight = targetContainer ? getTargetContainerHeight() : getViewPortHeight();
      var containerTop = ContainerTop();
      var containerBottom = ContainerBottom();
      var overTop = containerTop - position.top;
      var overBottom = position.top + elemData.height - containerBottom;

      if (elemData.height > containerHeight) {
        if (overTop > 0 && overBottom <= 0) {
          position.top = containerBottom - elemData.height;
        } else if (overBottom > 0 && overTop <= 0) {
          position.top = containerTop;
        } else {
          position.top = overTop > overBottom ? containerBottom - elemData.height : containerTop;
        }
      } else if (overTop > 0) {
        position.top += overTop;
      } else if (overBottom > 0) {
        position.top -= overBottom;
      }
    }

    return position;
  }

  function isCollide(element, viewPortElement, x, y) {
    if (viewPortElement === void 0) {
      viewPortElement = null;
    }

    var elemOffset = calculatePosition(element, 'left', 'top');

    if (x) {
      elemOffset.left = x;
    }

    if (y) {
      elemOffset.top = y;
    }

    var data = [];
    targetContainer = viewPortElement;
    parentDocument$1 = element.ownerDocument;
    var elementRect = element.getBoundingClientRect();
    var top = elemOffset.top;
    var left = elemOffset.left;
    var right = elemOffset.left + elementRect.width;
    var bottom = elemOffset.top + elementRect.height;
    var yAxis = topCollideCheck(top, bottom);
    var xAxis = leftCollideCheck(left, right);

    if (yAxis.topSide) {
      data.push('top');
    }

    if (xAxis.rightSide) {
      data.push('right');
    }

    if (xAxis.leftSide) {
      data.push('left');
    }

    if (yAxis.bottomSide) {
      data.push('bottom');
    }

    return data;
  }

  function flip(element, target, offsetX, offsetY, positionX, positionY, viewPortElement, axis, fixedParent) {
    if (viewPortElement === void 0) {
      viewPortElement = null;
    }

    if (axis === void 0) {
      axis = {
        X: true,
        Y: true
      };
    }

    if (!target || !element || !positionX || !positionY || !axis.X && !axis.Y) {
      return;
    }

    var tEdge = {
      TL: null,
      TR: null,
      BL: null,
      BR: null
    };
    var eEdge = {
      TL: null,
      TR: null,
      BL: null,
      BR: null
    };
    var elementRect = element.getBoundingClientRect();
    var pos = {
      posX: positionX,
      posY: positionY,
      offsetX: offsetX,
      offsetY: offsetY,
      position: {
        left: 0,
        top: 0
      }
    };
    targetContainer = viewPortElement;
    parentDocument$1 = target.ownerDocument;
    updateElementData(target, tEdge, pos, fixedParent, elementRect);
    setPosition(eEdge, pos, elementRect);

    if (axis.X) {
      leftFlip(target, eEdge, tEdge, pos, elementRect, true);
    }

    if (axis.Y && tEdge.TL.top > -1) {
      topFlip(target, eEdge, tEdge, pos, elementRect, true);
    }

    setPopup(element, pos, elementRect);
  }

  function setPopup(element, pos, elementRect) {
    var left = 0;
    var top = 0;

    if (element.offsetParent != null && (getComputedStyle(element.offsetParent).position === 'absolute' || getComputedStyle(element.offsetParent).position === 'relative')) {
      var data = calculatePosition(element.offsetParent, 'left', 'top', false, elementRect);
      left = data.left;
      top = data.top;
    }

    element.style.top = pos.position.top + pos.offsetY - top + 'px';
    element.style.left = pos.position.left + pos.offsetX - left + 'px';
  }

  function updateElementData(target, edge, pos, fixedParent, elementRect) {
    pos.position = calculatePosition(target, pos.posX, pos.posY, fixedParent, elementRect);
    edge.TL = calculatePosition(target, 'left', 'top', fixedParent, elementRect);
    edge.TR = calculatePosition(target, 'right', 'top', fixedParent, elementRect);
    edge.BR = calculatePosition(target, 'left', 'bottom', fixedParent, elementRect);
    edge.BL = calculatePosition(target, 'right', 'bottom', fixedParent, elementRect);
  }

  function setPosition(eStatus, pos, elementRect) {
    eStatus.TL = {
      top: pos.position.top + pos.offsetY,
      left: pos.position.left + pos.offsetX
    };
    eStatus.TR = {
      top: eStatus.TL.top,
      left: eStatus.TL.left + elementRect.width
    };
    eStatus.BL = {
      top: eStatus.TL.top + elementRect.height,
      left: eStatus.TL.left
    };
    eStatus.BR = {
      top: eStatus.TL.top + elementRect.height,
      left: eStatus.TL.left + elementRect.width
    };
  }

  function leftCollideCheck(left, right) {
    var leftSide = false;
    var rightSide = false;

    if (left - getBodyScrollLeft$1() < ContainerLeft()) {
      leftSide = true;
    }

    if (right > ContainerRight()) {
      rightSide = true;
    }

    return {
      leftSide: leftSide,
      rightSide: rightSide
    };
  }

  function leftFlip(target, edge, tEdge, pos, elementRect, deepCheck) {
    var collideSide = leftCollideCheck(edge.TL.left, edge.TR.left);

    if (tEdge.TL.left - getBodyScrollLeft$1() <= ContainerLeft()) {
      collideSide.leftSide = false;
    }

    if (tEdge.TR.left >= ContainerRight()) {
      collideSide.rightSide = false;
    }

    if (collideSide.leftSide && !collideSide.rightSide || !collideSide.leftSide && collideSide.rightSide) {
      if (pos.posX === 'right') {
        pos.posX = 'left';
      } else {
        pos.posX = 'right';
      }

      pos.offsetX = pos.offsetX + elementRect.width;
      pos.offsetX = -1 * pos.offsetX;
      pos.position = calculatePosition(target, pos.posX, pos.posY, false);
      setPosition(edge, pos, elementRect);

      if (deepCheck) {
        leftFlip(target, edge, tEdge, pos, elementRect, false);
      }
    }
  }

  function topFlip(target, edge, tEdge, pos, elementRect, deepCheck) {
    var collideSide = topCollideCheck(edge.TL.top, edge.BL.top);

    if (tEdge.TL.top - getBodyScrollTop$1() <= ContainerTop()) {
      collideSide.topSide = false;
    }

    if (tEdge.BL.top >= ContainerBottom()) {
      collideSide.bottomSide = false;
    }

    if (collideSide.topSide && !collideSide.bottomSide || !collideSide.topSide && collideSide.bottomSide) {
      if (pos.posY === 'top') {
        pos.posY = 'bottom';
      } else {
        pos.posY = 'top';
      }

      pos.offsetY = pos.offsetY + elementRect.height;
      pos.offsetY = -1 * pos.offsetY;
      pos.position = calculatePosition(target, pos.posX, pos.posY, false, elementRect);
      setPosition(edge, pos, elementRect);

      if (deepCheck) {
        topFlip(target, edge, tEdge, pos, elementRect, false);
      }
    }
  }

  function topCollideCheck(top, bottom) {
    var topSide = false;
    var bottomSide = false;

    if (top - getBodyScrollTop$1() < ContainerTop()) {
      topSide = true;
    }

    if (bottom > ContainerBottom()) {
      bottomSide = true;
    }

    return {
      topSide: topSide,
      bottomSide: bottomSide
    };
  }

  function getTargetContainerWidth() {
    return targetContainer.getBoundingClientRect().width;
  }

  function getTargetContainerHeight() {
    return targetContainer.getBoundingClientRect().height;
  }

  function getTargetContainerLeft() {
    return targetContainer.getBoundingClientRect().left;
  }

  function getTargetContainerTop() {
    return targetContainer.getBoundingClientRect().top;
  }

  function ContainerTop() {
    if (targetContainer) {
      return getTargetContainerTop();
    }

    return 0;
  }

  function ContainerLeft() {
    if (targetContainer) {
      return getTargetContainerLeft();
    }

    return 0;
  }

  function ContainerRight() {
    if (targetContainer) {
      return getBodyScrollLeft$1() + getTargetContainerLeft() + getTargetContainerWidth();
    }

    return getBodyScrollLeft$1() + getViewPortWidth();
  }

  function ContainerBottom() {
    if (targetContainer) {
      return getBodyScrollTop$1() + getTargetContainerTop() + getTargetContainerHeight();
    }

    return getBodyScrollTop$1() + getViewPortHeight();
  }

  function getBodyScrollTop$1() {
    // if(targetContainer)
    //     return targetContainer.scrollTop;
    return parentDocument$1.documentElement.scrollTop || parentDocument$1.body.scrollTop;
  }

  function getBodyScrollLeft$1() {
    // if(targetContainer)
    //     return targetContainer.scrollLeft;
    return parentDocument$1.documentElement.scrollLeft || parentDocument$1.body.scrollLeft;
  }

  function getViewPortHeight() {
    return window.innerHeight;
  }

  function getViewPortWidth() {
    var windowWidth = window.innerWidth;
    var offsetWidth = sf.base.isNullOrUndefined(document.documentElement) ? 0 : document.documentElement.offsetWidth;
    return windowWidth - (windowWidth - offsetWidth);
  }

  var __extends = undefined && undefined.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if ((typeof Reflect === "undefined" ? "undefined" : _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
      if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    }
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  /**
   * Specifies the offset position values.
   */


  var PositionData =
  /** @class */
  function (_super) {
    __extends(PositionData, _super);

    function PositionData() {
      return _super !== null && _super.apply(this, arguments) || this;
    }

    __decorate([sf.base.Property('left')], PositionData.prototype, "X", void 0);

    __decorate([sf.base.Property('top')], PositionData.prototype, "Y", void 0);

    return PositionData;
  }(sf.base.ChildProperty); // don't use space in classNames


  var CLASSNAMES = {
    ROOT: 'e-popup',
    RTL: 'e-rtl',
    OPEN: 'e-popup-open',
    CLOSE: 'e-popup-close'
  };
  /**
   * Represents the Popup Component
   * ```html
   * <div id="popup" style="position:absolute;height:100px;width:100px;">
   * <div style="margin:35px 25px;">Popup Content</div></div>
   * ```
   * ```typescript
   * <script>
   *   var popupObj = new Popup();
   *   popupObj.appendTo("#popup");
   * </script>
   * ```
   */

  var Popup =
  /** @class */
  function (_super) {
    __extends(Popup, _super);

    function Popup(element, options) {
      return _super.call(this, options, element) || this;
    }
    /**
     * Called internally if any of the property value changed.
     * @private
     */


    Popup.prototype.onPropertyChanged = function (newProp, oldProp) {
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];

        switch (prop) {
          case 'width':
            sf.base.setStyleAttribute(this.element, {
              'width': sf.base.formatUnit(newProp.width)
            });
            break;

          case 'height':
            sf.base.setStyleAttribute(this.element, {
              'height': sf.base.formatUnit(newProp.height)
            });
            break;

          case 'zIndex':
            sf.base.setStyleAttribute(this.element, {
              'zIndex': newProp.zIndex
            });
            break;

          case 'enableRtl':
            this.setEnableRtl();
            break;

          case 'position':
          case 'relateTo':
            this.refreshPosition();
            break;

          case 'offsetX':
            var x = newProp.offsetX - oldProp.offsetX;
            this.element.style.left = (parseInt(this.element.style.left, 10) + x).toString() + 'px';
            break;

          case 'offsetY':
            var y = newProp.offsetY - oldProp.offsetY;
            this.element.style.top = (parseInt(this.element.style.top, 10) + y).toString() + 'px';
            break;

          case 'content':
            this.setContent();
            break;

          case 'actionOnScroll':
            if (newProp.actionOnScroll !== 'none') {
              this.wireScrollEvents();
            } else {
              this.unwireScrollEvents();
            }

            break;
        }
      }
    };
    /**
     * gets the Component module name.
     * @private
     */


    Popup.prototype.getModuleName = function () {
      return 'popup';
    };
    /**
     * gets the persisted state properties of the Component.
     */


    Popup.prototype.getPersistData = function () {
      return this.addOnPersist([]);
    };
    /**
     * To destroy the control.
     */


    Popup.prototype.destroy = function () {
      this.element.classList.remove(CLASSNAMES.ROOT, CLASSNAMES.RTL, CLASSNAMES.OPEN, CLASSNAMES.CLOSE);
      this.unwireEvents();

      _super.prototype.destroy.call(this);
    };
    /**
     * To Initialize the control rendering
     * @private
     */


    Popup.prototype.render = function () {
      this.element.classList.add(CLASSNAMES.ROOT);
      var styles = {};

      if (this.zIndex !== 1000) {
        styles.zIndex = this.zIndex;
      }

      if (this.width !== 'auto') {
        styles.width = sf.base.formatUnit(this.width);
      }

      if (this.height !== 'auto') {
        styles.height = sf.base.formatUnit(this.height);
      }

      sf.base.setStyleAttribute(this.element, styles);
      this.fixedParent = false;
      this.setEnableRtl();
      this.setContent();
    };

    Popup.prototype.wireEvents = function () {
      if (sf.base.Browser.isDevice) {
        sf.base.EventHandler.add(window, 'orientationchange', this.orientationOnChange, this);
      }

      if (this.actionOnScroll !== 'none') {
        this.wireScrollEvents();
      }
    };

    Popup.prototype.wireScrollEvents = function () {
      if (this.getRelateToElement()) {
        for (var _i = 0, _a = this.getScrollableParent(this.getRelateToElement()); _i < _a.length; _i++) {
          var parent_1 = _a[_i];
          sf.base.EventHandler.add(parent_1, 'scroll', this.scrollRefresh, this);
        }
      }
    };

    Popup.prototype.unwireEvents = function () {
      if (sf.base.Browser.isDevice) {
        sf.base.EventHandler.remove(window, 'orientationchange', this.orientationOnChange);
      }

      if (this.actionOnScroll !== 'none') {
        this.unwireScrollEvents();
      }
    };

    Popup.prototype.unwireScrollEvents = function () {
      if (this.getRelateToElement()) {
        for (var _i = 0, _a = this.getScrollableParent(this.getRelateToElement()); _i < _a.length; _i++) {
          var parent_2 = _a[_i];
          sf.base.EventHandler.remove(parent_2, 'scroll', this.scrollRefresh);
        }
      }
    };

    Popup.prototype.getRelateToElement = function () {
      var relateToElement = this.relateTo === '' || sf.base.isNullOrUndefined(this.relateTo) ? document.body : this.relateTo;
      this.setProperties({
        relateTo: relateToElement
      }, true);
      return typeof this.relateTo === 'string' ? document.querySelector(this.relateTo) : this.relateTo;
    };

    Popup.prototype.scrollRefresh = function (e) {
      if (this.actionOnScroll === 'reposition') {
        if (!(this.element.offsetParent === e.target || this.element.offsetParent && this.element.offsetParent.tagName === 'BODY' && e.target.parentElement == null)) {
          this.refreshPosition();
        }
      } else if (this.actionOnScroll === 'hide') {
        this.hide();
      }

      if (this.actionOnScroll !== 'none') {
        if (this.getRelateToElement()) {
          var targetVisible = this.isElementOnViewport(this.getRelateToElement(), e.target);

          if (!targetVisible && !this.targetInvisibleStatus) {
            this.trigger('targetExitViewport');
            this.targetInvisibleStatus = true;
          } else if (targetVisible) {
            this.targetInvisibleStatus = false;
          }
        }
      }
    };
    /**
     * This method is to get the element visibility on viewport when scroll
     * the page. This method will returns true even though 1 px of element
     * part is in visible.
     */


    Popup.prototype.isElementOnViewport = function (relateToElement, scrollElement) {
      var scrollParents = this.getScrollableParent(relateToElement);

      for (var parent_3 = 0; parent_3 < scrollParents.length; parent_3++) {
        if (this.isElementVisible(relateToElement, scrollParents[parent_3])) {
          continue;
        } else {
          return false;
        }
      }

      return true;
    };

    Popup.prototype.isElementVisible = function (relateToElement, scrollElement) {
      var rect = this.checkGetBoundingClientRect(relateToElement);

      if (!rect.height || !rect.width) {
        return false;
      }

      if (!sf.base.isNullOrUndefined(this.checkGetBoundingClientRect(scrollElement))) {
        var parent_4 = scrollElement.getBoundingClientRect();
        return !(rect.bottom < parent_4.top) && !(rect.bottom > parent_4.bottom) && !(rect.right > parent_4.right) && !(rect.left < parent_4.left);
      } else {
        var win = window;
        var windowView = {
          top: win.scrollY,
          left: win.scrollX,
          right: win.scrollX + win.outerWidth,
          bottom: win.scrollY + win.outerHeight
        };
        var off = calculatePosition(relateToElement);
        var ele = {
          top: off.top,
          left: off.left,
          right: off.left + rect.width,
          bottom: off.top + rect.height
        };
        var elementView = {
          top: windowView.bottom - ele.top,
          left: windowView.right - ele.left,
          bottom: ele.bottom - windowView.top,
          right: ele.right - windowView.left
        };
        return elementView.top > 0 && elementView.left > 0 && elementView.right > 0 && elementView.bottom > 0;
      }
    };
    /**
     * Initialize the event handler
     * @private
     */


    Popup.prototype.preRender = function () {//There is no event handler
    };

    Popup.prototype.setEnableRtl = function () {
      this.reposition();
      this.enableRtl ? this.element.classList.add(CLASSNAMES.RTL) : this.element.classList.remove(CLASSNAMES.RTL);
    };

    Popup.prototype.setContent = function () {
      if (!sf.base.isNullOrUndefined(this.content)) {
        this.element.innerHTML = '';

        if (typeof this.content === 'string') {
          this.element.textContent = this.content;
        } else {
          this.element.appendChild(this.content);
        }
      }
    };

    Popup.prototype.orientationOnChange = function () {
      var _this = this;

      setTimeout(function () {
        _this.refreshPosition();
      }, 200);
    };
    /**
     * Based on the `relative` element and `offset` values, `Popup` element position will refreshed.
     */


    Popup.prototype.refreshPosition = function (target, collision) {
      if (!sf.base.isNullOrUndefined(target)) {
        this.checkFixedParent(target);
      }

      this.reposition();

      if (!collision) {
        this.checkCollision();
      }
    };

    Popup.prototype.reposition = function () {
      var pos;
      var position;
      var relateToElement = this.getRelateToElement();

      if (typeof this.position.X === 'number' && typeof this.position.Y === 'number') {
        pos = {
          left: this.position.X,
          top: this.position.Y
        };
      } else if (typeof this.position.X === 'string' && typeof this.position.Y === 'number' || typeof this.position.X === 'number' && typeof this.position.Y === 'string') {
        var display = this.element.style.display;
        var parentDisplay = void 0;
        this.element.style.display = 'block';

        if (this.element.classList.contains('e-dlg-modal')) {
          parentDisplay = this.element.parentElement.style.display;
          this.element.parentElement.style.display = 'block';
        }

        position = this.getAnchorPosition(relateToElement, this.element, this.position, this.offsetX, this.offsetY);

        if (typeof this.position.X === 'string') {
          pos = {
            left: position.left,
            top: this.position.Y
          };
        } else {
          pos = {
            left: this.position.X,
            top: position.top
          };
        }

        this.element.style.display = display;

        if (this.element.classList.contains('e-dlg-modal')) {
          this.element.parentElement.style.display = parentDisplay;
        }
      } else if (relateToElement) {
        var display = this.element.style.display;
        this.element.style.display = 'block';
        pos = this.getAnchorPosition(relateToElement, this.element, this.position, this.offsetX, this.offsetY);
        this.element.style.display = display;
      } else {
        pos = {
          left: 0,
          top: 0
        };
      }

      if (!sf.base.isNullOrUndefined(pos)) {
        this.element.style.left = pos.left + 'px';
        this.element.style.top = pos.top + 'px';
      }
    };

    Popup.prototype.checkGetBoundingClientRect = function (ele) {
      var eleRect;

      try {
        eleRect = ele.getBoundingClientRect();
        return eleRect;
      } catch (error) {
        return null;
      }
    };

    Popup.prototype.getAnchorPosition = function (anchorEle, ele, position, offsetX, offsetY) {
      var eleRect = this.checkGetBoundingClientRect(ele);
      var anchorRect = this.checkGetBoundingClientRect(anchorEle);

      if (sf.base.isNullOrUndefined(eleRect) || sf.base.isNullOrUndefined(anchorRect)) {
        return null;
      }

      var anchor = anchorEle;
      var anchorPos = {
        left: 0,
        top: 0
      };

      if (ele.offsetParent && ele.offsetParent.tagName === 'BODY' && anchorEle.tagName === 'BODY') {
        anchorPos = calculatePosition(anchorEle);
      } else {
        if (ele.classList.contains('e-dlg-modal') && anchor.tagName !== 'BODY') {
          ele = ele.parentElement;
        }

        anchorPos = calculateRelativeBasedPosition(anchor, ele);
      }

      switch (position.X) {
        default:
        case 'left':
          break;

        case 'center':
          if (ele.classList.contains('e-dlg-modal') && anchor.tagName === 'BODY' && this.targetType === 'container') {
            anchorPos.left += window.innerWidth / 2 - eleRect.width / 2;
          } else if (this.targetType === 'container') {
            anchorPos.left += anchorRect.width / 2 - eleRect.width / 2;
          } else {
            anchorPos.left += anchorRect.width / 2;
          }

          break;

        case 'right':
          if (ele.classList.contains('e-dlg-modal') && anchor.tagName === 'BODY' && this.targetType === 'container') {
            anchorPos.left += window.innerWidth - eleRect.width;
          } else if (this.targetType === 'container') {
            anchorPos.left += anchorRect.width - eleRect.width;
          } else {
            anchorPos.left += anchorRect.width;
          }

          break;
      }

      switch (position.Y) {
        default:
        case 'top':
          break;

        case 'center':
          if (ele.classList.contains('e-dlg-modal') && anchor.tagName === 'BODY' && this.targetType === 'container') {
            anchorPos.top += window.innerHeight / 2 - eleRect.height / 2;
          } else if (this.targetType === 'container') {
            anchorPos.top += anchorRect.height / 2 - eleRect.height / 2;
          } else {
            anchorPos.top += anchorRect.height / 2;
          }

          break;

        case 'bottom':
          if (ele.classList.contains('e-dlg-modal') && anchor.tagName === 'BODY' && this.targetType === 'container') {
            anchorPos.top += window.innerHeight - eleRect.height;
          } else if (this.targetType === 'container') {
            anchorPos.top += anchorRect.height - eleRect.height;
          } else {
            anchorPos.top += anchorRect.height;
          }

          break;
      }

      anchorPos.left += offsetX;
      anchorPos.top += offsetY;
      return anchorPos;
    };

    Popup.prototype.callFlip = function (param) {
      var relateToElement = this.getRelateToElement();
      flip(this.element, relateToElement, this.offsetX, this.offsetY, this.position.X, this.position.Y, this.viewPortElement, param, this.fixedParent);
    };

    Popup.prototype.callFit = function (param) {
      if (isCollide(this.element, this.viewPortElement).length !== 0) {
        if (sf.base.isNullOrUndefined(this.viewPortElement)) {
          var data = fit(this.element, this.viewPortElement, param);

          if (param.X) {
            this.element.style.left = data.left + 'px';
          }

          if (param.Y) {
            this.element.style.top = data.top + 'px';
          }
        } else {
          var elementRect = this.checkGetBoundingClientRect(this.element);
          var viewPortRect = this.checkGetBoundingClientRect(this.viewPortElement);

          if (sf.base.isNullOrUndefined(elementRect) || sf.base.isNullOrUndefined(viewPortRect)) {
            return null;
          }

          if (param && param.Y === true) {
            if (viewPortRect.top > elementRect.top) {
              this.element.style.top = '0px';
            } else if (viewPortRect.bottom < elementRect.bottom) {
              this.element.style.top = parseInt(this.element.style.top, 10) - (elementRect.bottom - viewPortRect.bottom) + 'px';
            }
          }

          if (param && param.X === true) {
            if (viewPortRect.right < elementRect.right) {
              this.element.style.left = parseInt(this.element.style.left, 10) - (elementRect.right - viewPortRect.right) + 'px';
            } else if (viewPortRect.left > elementRect.left) {
              this.element.style.left = parseInt(this.element.style.left, 10) + (viewPortRect.left - elementRect.left) + 'px';
            }
          }
        }
      }
    };

    Popup.prototype.checkCollision = function () {
      var horz = this.collision.X;
      var vert = this.collision.Y;

      if (horz === 'none' && vert === 'none') {
        return;
      }

      if (horz === 'flip' && vert === 'flip') {
        this.callFlip({
          X: true,
          Y: true
        });
      } else if (horz === 'fit' && vert === 'fit') {
        this.callFit({
          X: true,
          Y: true
        });
      } else {
        if (horz === 'flip') {
          this.callFlip({
            X: true,
            Y: false
          });
        } else if (vert === 'flip') {
          this.callFlip({
            Y: true,
            X: false
          });
        }

        if (horz === 'fit') {
          this.callFit({
            X: true,
            Y: false
          });
        } else if (vert === 'fit') {
          this.callFit({
            X: false,
            Y: true
          });
        }
      }
    };
    /**
     * Shows the popup element from screen.
     * @param { AnimationModel | Function } collisionOrAnimationOptions? - To pass animation options or collision function.
     * @param { Function } collision? - To pass the collision function.
     * @param { HTMLElement } relativeElement? - To calculate the zIndex value dynamically.
     */


    Popup.prototype.show = function (animationOptions, relativeElement) {
      var _this = this;

      this.wireEvents();

      if (this.zIndex === 1000 || !sf.base.isNullOrUndefined(relativeElement)) {
        var zIndexElement = sf.base.isNullOrUndefined(relativeElement) ? this.element : relativeElement;
        this.zIndex = getZindexPartial(zIndexElement);
        sf.base.setStyleAttribute(this.element, {
          'zIndex': this.zIndex
        });
      }

      animationOptions = !sf.base.isNullOrUndefined(animationOptions) && _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(animationOptions) === 'object' ? animationOptions : this.showAnimation;

      if (this.collision.X !== 'none' || this.collision.Y !== 'none') {
        sf.base.removeClass([this.element], CLASSNAMES.CLOSE);
        sf.base.addClass([this.element], CLASSNAMES.OPEN);
        this.checkCollision();
        sf.base.removeClass([this.element], CLASSNAMES.OPEN);
        sf.base.addClass([this.element], CLASSNAMES.CLOSE);
      }

      if (!sf.base.isNullOrUndefined(animationOptions)) {
        animationOptions.begin = function () {
          if (!_this.isDestroyed) {
            sf.base.removeClass([_this.element], CLASSNAMES.CLOSE);
            sf.base.addClass([_this.element], CLASSNAMES.OPEN);
          }
        };

        animationOptions.end = function () {
          if (!_this.isDestroyed) {
            _this.trigger('open');
          }
        };

        new sf.base.Animation(animationOptions).animate(this.element);
      } else {
        sf.base.removeClass([this.element], CLASSNAMES.CLOSE);
        sf.base.addClass([this.element], CLASSNAMES.OPEN);
        this.trigger('open');
      }
    };
    /**
     * Hides the popup element from screen.
     * @param { AnimationModel } animationOptions? - To give the animation options.
     */


    Popup.prototype.hide = function (animationOptions) {
      var _this = this;

      animationOptions = !sf.base.isNullOrUndefined(animationOptions) && _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(animationOptions) === 'object' ? animationOptions : this.hideAnimation;

      if (!sf.base.isNullOrUndefined(animationOptions)) {
        animationOptions.end = function () {
          if (!_this.isDestroyed) {
            sf.base.removeClass([_this.element], CLASSNAMES.OPEN);
            sf.base.addClass([_this.element], CLASSNAMES.CLOSE);

            _this.trigger('close');
          }
        };

        new sf.base.Animation(animationOptions).animate(this.element);
      } else {
        sf.base.removeClass([this.element], CLASSNAMES.OPEN);
        sf.base.addClass([this.element], CLASSNAMES.CLOSE);
        this.trigger('close');
      }

      this.unwireEvents();
    };
    /**
     * Gets scrollable parent elements for the given element.
     * @param { HTMLElement } element - Specify the element to get the scrollable parents of it.
     */


    Popup.prototype.getScrollableParent = function (element) {
      this.checkFixedParent(element);
      return getScrollableParent(element, this.fixedParent);
    };

    Popup.prototype.checkFixedParent = function (element) {
      var parent = element.parentElement;

      while (parent && parent.tagName !== 'HTML') {
        var parentStyle = getComputedStyle(parent);

        if (parentStyle.position === 'fixed' && this.element.offsetParent && this.element.offsetParent.tagName === 'BODY') {
          this.element.style.position = 'fixed';
          this.fixedParent = true;
        }

        parent = parent.parentElement;

        if (sf.base.isNullOrUndefined(this.element.offsetParent) && parentStyle.position === 'fixed' && this.element.style.position === 'fixed') {
          this.fixedParent = true;
        }
      }
    };

    __decorate([sf.base.Property('auto')], Popup.prototype, "height", void 0);

    __decorate([sf.base.Property('auto')], Popup.prototype, "width", void 0);

    __decorate([sf.base.Property(null)], Popup.prototype, "content", void 0);

    __decorate([sf.base.Property('container')], Popup.prototype, "targetType", void 0);

    __decorate([sf.base.Property(null)], Popup.prototype, "viewPortElement", void 0);

    __decorate([sf.base.Property({
      X: 'none',
      Y: 'none'
    })], Popup.prototype, "collision", void 0);

    __decorate([sf.base.Property('')], Popup.prototype, "relateTo", void 0);

    __decorate([sf.base.Complex({}, PositionData)], Popup.prototype, "position", void 0);

    __decorate([sf.base.Property(0)], Popup.prototype, "offsetX", void 0);

    __decorate([sf.base.Property(0)], Popup.prototype, "offsetY", void 0);

    __decorate([sf.base.Property(1000)], Popup.prototype, "zIndex", void 0);

    __decorate([sf.base.Property(false)], Popup.prototype, "enableRtl", void 0);

    __decorate([sf.base.Property('reposition')], Popup.prototype, "actionOnScroll", void 0);

    __decorate([sf.base.Property(null)], Popup.prototype, "showAnimation", void 0);

    __decorate([sf.base.Property(null)], Popup.prototype, "hideAnimation", void 0);

    __decorate([sf.base.Event()], Popup.prototype, "open", void 0);

    __decorate([sf.base.Event()], Popup.prototype, "close", void 0);

    __decorate([sf.base.Event()], Popup.prototype, "targetExitViewport", void 0);

    Popup = __decorate([sf.base.NotifyPropertyChanges], Popup);
    return Popup;
  }(sf.base.Component);
  /**
   * Gets scrollable parent elements for the given element.
   * @param { HTMLElement } element - Specify the element to get the scrollable parents of it.
   * @private
   */


  function getScrollableParent(element, fixedParent) {
    var eleStyle = getComputedStyle(element);
    var scrollParents = [];
    var overflowRegex = /(auto|scroll)/;
    var parent = element.parentElement;

    while (parent && parent.tagName !== 'HTML') {
      var parentStyle = getComputedStyle(parent);

      if (!(eleStyle.position === 'absolute' && parentStyle.position === 'static') && overflowRegex.test(parentStyle.overflow + parentStyle.overflowY + parentStyle.overflowX)) {
        scrollParents.push(parent);
      }

      parent = parent.parentElement;
    }

    if (!fixedParent) {
      scrollParents.push(document);
    }

    return scrollParents;
  }
  /**
   * Gets the maximum z-index of the given element.
   * @param { HTMLElement } element - Specify the element to get the maximum z-index of it.
   * @private
   */


  function getZindexPartial(element) {
    // upto body traversal
    var parent = element.parentElement;
    var parentZindex = [];

    while (parent) {
      if (parent.tagName !== 'BODY') {
        var index = document.defaultView.getComputedStyle(parent, null).getPropertyValue('z-index');
        var position = document.defaultView.getComputedStyle(parent, null).getPropertyValue('position');

        if (index !== 'auto' && position !== 'static') {
          parentZindex.push(index);
        }

        parent = parent.parentElement;
      } else {
        break;
      }
    } //Body direct children element traversal


    var childrenZindex = [];

    for (var i = 0; i < document.body.children.length; i++) {
      if (!element.isEqualNode(document.body.children[i])) {
        var index = document.defaultView.getComputedStyle(document.body.children[i], null).getPropertyValue('z-index');
        var position = document.defaultView.getComputedStyle(document.body.children[i], null).getPropertyValue('position');

        if (index !== 'auto' && position !== 'static') {
          childrenZindex.push(index);
        }
      }
    }

    childrenZindex.push('999');
    var siblingsZindex = [];

    if (!sf.base.isNullOrUndefined(element.parentElement) && element.parentElement.tagName !== 'BODY') {
      var childNodes = [].slice.call(element.parentElement.children);

      for (var i = 0; i < childNodes.length; i++) {
        var index = document.defaultView.getComputedStyle(childNodes[i], null).getPropertyValue('z-index');
        var position = document.defaultView.getComputedStyle(childNodes[i], null).getPropertyValue('position');

        if (index !== 'auto' && position !== 'static') {
          siblingsZindex.push(index);
        }
      }
    }

    var finalValue = parentZindex.concat(childrenZindex, siblingsZindex);
    var currentZindexValue = Math.max.apply(Math, finalValue) + 1; // Checking the max-zindex value

    return currentZindexValue > 2147483647 ? 2147483647 : currentZindexValue;
  }
  /**
   * Gets the maximum z-index of the page.
   * @param { HTMLElement } tagName - Specify the tagName to get the maximum z-index of it.
   * @private
   */


  var TAPHOLD_THRESHOLD = 500;
  var SHOW_POINTER_TIP_GAP = 0;
  var HIDE_POINTER_TIP_GAP = 8;
  var MOUSE_TRAIL_GAP = 2;
  var POINTER_ADJUST = 2;
  var ROOT = 'e-tooltip';
  var TOOLTIP_WRAP = 'e-tooltip-wrap';
  var ARROW_TIP = 'e-arrow-tip';
  var ARROW_TIP_OUTER = 'e-arrow-tip-outer';
  var ARROW_TIP_INNER = 'e-arrow-tip-inner';
  var TIP_BOTTOM = 'e-tip-bottom';
  var TIP_TOP = 'e-tip-top';
  var TIP_LEFT = 'e-tip-left';
  var TIP_RIGHT = 'e-tip-right';
  var POPUP_ROOT = 'e-popup';
  var POPUP_OPEN = 'e-popup-open';
  var POPUP_CLOSE = 'e-popup-close';
  var POPUP_LIB = 'e-lib';
  var HIDDDEN = 'e-hidden';
  var BIGGER = 'e-bigger';
  var RIGHT = 'Right';
  var BOTTOM = 'Bottom';
  var TOP = 'Top';
  var LEFT = 'Left';
  var CENTER = 'Center';
  var END = 'End';
  var START = 'Start';
  var TOPLEFT = 'TopLeft';
  var TOPRIGHT = 'TopRight';
  var BOTTOMLEFT = 'BottomLeft';
  var BOTTOMCENTER = 'BottomCenter';
  var BOTTOMRIGHT = 'BottomRight';
  var LEFTTOP = 'LeftTop';
  var LEFTCENTER = 'LeftCenter';
  var LEFTBOTTOM = 'LeftBottom';
  var RIGHTTOP = 'RightTop';
  var RIGHTCENTER = 'RightCenter';
  var RIGHTBOTTOM = 'RightBottom';
  var PLACEHOLDER = '_content_placeholder';
  var CONTENT = '_content';
  var TIPCONTENT = 'e-tip-content';

  var SfTooltip =
  /** @class */
  function () {
    function SfTooltip(element, ref, properties, eventList) {
      this.popupObj = null;
      this.isPositionUpdate = false;
      this.isOffsetXUpdate = false;
      this.isOffsetYUpdate = false;
      this.tipClass = TIP_BOTTOM;
      this.tooltipPositionX = 'Center';
      this.tooltipPositionY = 'Top';
      this.isContiniousOpen = false;
      this.isRestrictUpdate = false;
      this.contentTargetValue = null;
      this.contentEvent = null;
      this.contentAnimation = null;
      this.beforeCloseAnimation = null;
      this.element = element;
      this.ctrlId = this.element.id;
      this.properties = properties;
      this.dotnetRef = ref;
      this.element.blazor__instance = this;
      this.element.eventList = eventList;
    }

    SfTooltip.prototype.getTriggerList = function (trigger) {
      if (trigger === 'Auto') {
        trigger = sf.base.Browser.isDevice ? 'Hover' : 'Hover Focus';
      }

      return trigger.split(' ');
    };

    SfTooltip.prototype.formatPosition = function () {
      var _a, _b;

      if (this.properties.position.indexOf('Top') === 0 || this.properties.position.indexOf('Bottom') === 0) {
        _a = this.properties.position.split(/(?=[A-Z])/), this.tooltipPositionY = _a[0], this.tooltipPositionX = _a[1];
      } else {
        _b = this.properties.position.split(/(?=[A-Z])/), this.tooltipPositionX = _b[0], this.tooltipPositionY = _b[1];
      }
    };

    SfTooltip.prototype.wireEvents = function (trigger) {
      var triggerList = this.getTriggerList(trigger);

      for (var _i = 0, triggerList_1 = triggerList; _i < triggerList_1.length; _i++) {
        var opensOn = triggerList_1[_i];

        if (opensOn === 'Custom') {
          return;
        }

        if (opensOn === 'Focus') {
          this.wireFocusEvents();
        }

        if (opensOn === 'Click') {
          sf.base.EventHandler.add(this.element, sf.base.Browser.touchStartEvent, this.targetClick, this);
        }

        if (opensOn === 'Hover') {
          if (sf.base.Browser.isDevice) {
            this.touchModule = new sf.base.Touch(this.element, {
              tapHoldThreshold: TAPHOLD_THRESHOLD,
              tapHold: this.tapHoldHandler.bind(this)
            });
            sf.base.EventHandler.add(this.element, sf.base.Browser.touchEndEvent, this.touchEndHandler, this);
          } else {
            sf.base.EventHandler.add(this.element, 'mouseover', this.targetHover, this);

            if (!this.properties.isSticky) {
              sf.base.EventHandler.add(this.element, 'mouseleave', this.onMouseOut, this);
            }
          }
        }
      }

      sf.base.EventHandler.add(document, 'touchend', this.touchEnd, this);
      sf.base.EventHandler.add(document, 'scroll wheel', this.scrollHandler, this);
      sf.base.EventHandler.add(document, 'keydown', this.keyDown, this);
      window.addEventListener('resize', this.onWindowResize.bind(this));
    };

    SfTooltip.prototype.onWindowResize = function () {
      if (!this.isHidden()) {
        this.reposition(this.findTarget());
      }
    };

    SfTooltip.prototype.wireFocusEvents = function () {
      if (!sf.base.isNullOrUndefined(this.properties.target)) {
        var targetList = [].slice.call(this.element.querySelectorAll(this.properties.target));

        for (var _i = 0, targetList_1 = targetList; _i < targetList_1.length; _i++) {
          var target = targetList_1[_i];
          sf.base.EventHandler.add(target, 'focus', this.targetHover, this);
        }
      } else {
        sf.base.EventHandler.add(this.element, 'focus', this.targetHover, this);
      }
    };

    SfTooltip.prototype.wireMouseEvents = function (e, target) {
      if (this.tooltipEle) {
        if (!this.properties.isSticky) {
          if (e.type === 'focus') {
            sf.base.EventHandler.add(target, 'blur', this.onMouseOut, this);
          }
        }

        if (this.properties.mouseTrail) {
          sf.base.EventHandler.add(target, 'mousemove touchstart mouseenter', this.onMouseMove, this);
        }
      }
    };

    SfTooltip.prototype.unwireEvents = function (trigger) {
      var triggerList = this.getTriggerList(trigger);

      for (var _i = 0, triggerList_2 = triggerList; _i < triggerList_2.length; _i++) {
        var opensOn = triggerList_2[_i];

        if (opensOn === 'Custom') {
          return;
        }

        if (opensOn === 'Focus') {
          this.unwireFocusEvents();
        }

        if (opensOn === 'Click') {
          sf.base.EventHandler.remove(this.element, sf.base.Browser.touchStartEvent, this.targetClick);
        }

        if (opensOn === 'Hover') {
          if (sf.base.Browser.isDevice) {
            if (this.touchModule) {
              this.touchModule.destroy();
            }

            sf.base.EventHandler.remove(this.element, sf.base.Browser.touchEndEvent, this.touchEndHandler);
          } else {
            sf.base.EventHandler.remove(this.element, 'mouseover', this.targetHover);

            if (!this.properties.isSticky) {
              sf.base.EventHandler.remove(this.element, 'mouseleave', this.onMouseOut);
            }
          }
        }
      }

      sf.base.EventHandler.remove(document, 'touchend', this.touchEnd);
      sf.base.EventHandler.remove(document, 'scroll wheel', this.scrollHandler);
      sf.base.EventHandler.remove(document, 'keydown', this.keyDown);
      window.removeEventListener('resize', this.onWindowResize.bind(this));
    };

    SfTooltip.prototype.unwireFocusEvents = function () {
      if (!sf.base.isNullOrUndefined(this.properties.target)) {
        var targetList = [].slice.call(this.element.querySelectorAll(this.properties.target));

        for (var _i = 0, targetList_2 = targetList; _i < targetList_2.length; _i++) {
          var target = targetList_2[_i];
          sf.base.EventHandler.remove(target, 'focus', this.targetHover);
        }
      } else {
        sf.base.EventHandler.remove(this.element, 'focus', this.targetHover);
      }
    };

    SfTooltip.prototype.unwireMouseEvents = function (target) {
      if (!this.properties.isSticky) {
        var triggerList = this.getTriggerList(this.properties.opensOn);

        for (var _i = 0, triggerList_3 = triggerList; _i < triggerList_3.length; _i++) {
          var opensOn = triggerList_3[_i];

          if (opensOn === 'Focus') {
            sf.base.EventHandler.remove(target, 'blur', this.onMouseOut);
          }
        }
      }

      if (this.properties.mouseTrail) {
        sf.base.EventHandler.remove(target, 'mousemove touchstart mouseenter', this.onMouseMove);
      }
    };

    SfTooltip.prototype.findTarget = function () {
      return document.querySelector('[data-tooltip-id= ' + this.ctrlId + '_content]');
    };

    SfTooltip.prototype.addDescribedBy = function (target, id) {
      var describedby = (sf.base.getAttributeOrDefault(target, 'aria-describedby', null) || '').split(/\s+/);

      if (describedby.indexOf(id) < 0) {
        describedby.push(id);
      }

      sf.base.attributes(target, {
        'aria-describedby': describedby.join(' ').trim(),
        'data-tooltip-id': id
      });
    };

    SfTooltip.prototype.removeDescribedBy = function (target) {
      var id = sf.base.getAttributeOrDefault(target, 'data-tooltip-id', null);
      var describedby = (sf.base.getAttributeOrDefault(target, 'aria-describedby', null) || '').split(/\s+/);
      var index = describedby.indexOf(id);

      if (index !== -1) {
        describedby.splice(index, 1);
      }

      target.removeAttribute('data-tooltip-id');
      var orgdescribedby = describedby.join(' ').trim();
      orgdescribedby ? sf.base.attributes(target, {
        'aria-describedby': orgdescribedby
      }) : target.removeAttribute('aria-describedby');
    };

    SfTooltip.prototype.clear = function () {
      if (this.tooltipEle) {
        sf.base.removeClass([this.tooltipEle], POPUP_CLOSE);
        sf.base.addClass([this.tooltipEle], POPUP_OPEN);
      }

      if (this.isHidden()) {
        if (this.popupObj) {
          this.popupObj.destroy();
        }

        if (this.tooltipEle) {
          sf.base.setStyleAttribute(this.tooltipEle, {
            'display': 'none'
          });
          var contentElement = document.getElementById(this.ctrlId + PLACEHOLDER);

          if (contentElement) {
            contentElement.appendChild(this.tooltipEle);
          }

          this.dotnetRef.invokeMethodAsync('CreateTooltip', JSON.stringify(false));
        }

        this.tooltipEle = null;
        this.popupObj = null;
      }
    };

    SfTooltip.prototype.tapHoldHandler = function (evt) {
      this.targetHover(evt.originalEvent);
    };

    SfTooltip.prototype.touchEndHandler = function (e) {
      if (!this.properties.isSticky) {
        this.hideTooltip(this.properties.animation.close);
      }
    };

    SfTooltip.prototype.targetClick = function (e) {
      var target = this.properties.target ? sf.base.closest(e.target, this.properties.target) : this.element;

      if (!sf.base.isNullOrUndefined(target)) {
        if (sf.base.getAttributeOrDefault(target, 'data-tooltip-id', null) === null) {
          this.targetHover(e);
        } else if (!this.properties.isSticky) {
          this.hideTooltip(this.properties.animation.close, e, target);
        }
      }
    };

    SfTooltip.prototype.restoreElement = function (target) {
      this.unwireMouseEvents(target);

      if (!sf.base.isNullOrUndefined(sf.base.getAttributeOrDefault(target, 'data-content', null))) {
        sf.base.attributes(target, {
          'title': sf.base.getAttributeOrDefault(target, 'data-content', null)
        });
        target.removeAttribute('data-content');
      }

      this.removeDescribedBy(target);
    };

    SfTooltip.prototype.targetHover = function (e) {
      var target = this.properties.target ? sf.base.closest(e.target, this.properties.target) : this.element;

      if (sf.base.isNullOrUndefined(target) || sf.base.getAttributeOrDefault(target, 'data-tooltip-id', null) !== null) {
        return;
      }

      var targetList = [].slice.call(document.querySelectorAll('[data-tooltip-id= ' + this.ctrlId + '_content]'));

      for (var _i = 0, targetList_3 = targetList; _i < targetList_3.length; _i++) {
        var target_1 = targetList_3[_i];
        this.restoreElement(target_1);
      }

      this.showTooltip(target, this.properties.animation.open, e);
    };

    SfTooltip.prototype.isHidden = function () {
      return this.tooltipEle ? this.tooltipEle.classList.contains(POPUP_OPEN) : true;
    };

    SfTooltip.prototype.showTooltip = function (target, showAnimation, e) {
      this.isContiniousOpen = !sf.base.isNullOrUndefined(this.tooltipEle);
      this.tooltipEventArgs = {
        type: e ? e.type.toString() : null,
        cancel: false,
        target: this.getDomObject('target', target),
        event: e ? e : null,
        element: this.getDomObject('tooltipElement', this.tooltipEle),
        isInteracted: !sf.base.isNullOrUndefined(e),
        name: 'beforeRender'
      };
      this.contentTargetValue = target;
      this.contentEvent = e;
      this.contentAnimation = showAnimation;
      this.isRestrictUpdate = this.element.eventList.beforeRender && !this.isHidden();
      this.element.eventList.beforeRender ? this.triggerEvent('TriggerBeforeRenderEvent', this.tooltipEventArgs) : this.beforeRenderCallBack(false);
    };

    SfTooltip.prototype.triggerEvent = function (eventName, args) {
      this.dotnetRef.invokeMethodAsync(eventName, JSON.stringify(args));
    };

    SfTooltip.prototype.beforeRenderCallBack = function (cancel) {
      if (cancel) {
        this.clear();
      } else {
        if (sf.base.isNullOrUndefined(this.tooltipEle)) {
          this.dotnetRef.invokeMethodAsync('CreateTooltip', JSON.stringify(true));
        } else if (this.isContiniousOpen && !this.isRestrictUpdate) {
          this.contentUpdated();
        } else {
          this.isRestrictUpdate = false;
        }
      }
    };

    SfTooltip.prototype.checkCollision = function (target, x, y) {
      var elePos = {
        left: x,
        top: y,
        position: this.properties.position,
        horizontal: this.tooltipPositionX,
        vertical: this.tooltipPositionY
      };
      var affectedPos = isCollide(this.tooltipEle, this.properties.target ? this.element : null, x, y);

      if (affectedPos.length > 0) {
        elePos.horizontal = affectedPos.indexOf('left') >= 0 ? RIGHT : affectedPos.indexOf('right') >= 0 ? LEFT : this.tooltipPositionX;
        elePos.vertical = affectedPos.indexOf('top') >= 0 ? BOTTOM : affectedPos.indexOf('bottom') >= 0 ? TOP : this.tooltipPositionY;
      }

      return elePos;
    };

    SfTooltip.prototype.collisionFlipFit = function (target, x, y) {
      var elePos = this.checkCollision(target, x, y);
      var newpos = elePos.position;

      if (this.tooltipPositionY !== elePos.vertical) {
        newpos = this.properties.position.indexOf(BOTTOM) === 0 || this.properties.position.indexOf('Top') === 0 ? elePos.vertical + this.tooltipPositionX : this.tooltipPositionX + elePos.vertical;
      }

      if (this.tooltipPositionX !== elePos.horizontal) {
        if (newpos.indexOf(LEFT) === 0) {
          elePos.vertical = newpos === LEFTTOP || newpos === LEFTCENTER ? TOP : BOTTOM;
          newpos = elePos.vertical + LEFT;
        }

        if (newpos.indexOf(RIGHT) === 0) {
          elePos.vertical = newpos === RIGHTTOP || newpos === RIGHTCENTER ? TOP : BOTTOM;
          newpos = elePos.vertical + RIGHT;
        }

        elePos.horizontal = this.tooltipPositionX;
      }

      this.tooltipEventArgs = {
        type: null,
        cancel: false,
        target: this.getDomObject('target', target),
        event: null,
        isInteracted: false,
        element: this.getDomObject('tooltipElement', this.tooltipEle),
        collidedPosition: newpos,
        name: 'beforeCollision'
      };
      this.isRestrictUpdate = this.element.eventList.beforeCollision && !this.isHidden();

      if (this.element.eventList.beforeCollision) {
        this.triggerEvent('TriggerBeforeCollisionEvent', this.tooltipEventArgs);
      }

      if (elePos.position !== newpos) {
        var pos = calculatePosition(target, elePos.horizontal, elePos.vertical);
        this.adjustArrow(target, newpos, elePos.horizontal, elePos.vertical);
        var offsetPos = this.calculateTooltipOffset(newpos);
        offsetPos.top -= 'TopBottom'.indexOf(this.properties.position.split(/(?=[A-Z])/)[0]) !== -1 && 'TopBottom'.indexOf(newpos.split(/(?=[A-Z])/)[0]) !== -1 ? 2 * this.properties.offsetY : 0;
        offsetPos.left -= 'RightLeft'.indexOf(this.properties.position.split(/(?=[A-Z])/)[0]) !== -1 && 'RightLeft'.indexOf(newpos.split(/(?=[A-Z])/)[0]) !== -1 ? 2 * this.properties.offsetX : 0;
        elePos.position = newpos;
        elePos.left = pos.left + offsetPos.left;
        elePos.top = pos.top + offsetPos.top;
      } else {
        this.adjustArrow(target, newpos, elePos.horizontal, elePos.vertical);
      }

      var eleOffset = {
        left: elePos.left,
        top: elePos.top
      };
      var left = fit(this.tooltipEle, this.properties.target ? this.element : null, {
        X: true,
        Y: false
      }, eleOffset).left;
      sf.base.setStyleAttribute(this.tooltipEle, {
        'display': 'block'
      });

      if (this.properties.showTipPointer && (newpos.indexOf('Bottom') === 0 || newpos.indexOf('Top') === 0)) {
        var arrowEle = this.tooltipEle.querySelector('.' + ARROW_TIP);
        var arrowleft = parseInt(arrowEle.style.left, 10) - (left - elePos.left);

        if (arrowleft < 0) {
          arrowleft = 0;
        } else if (arrowleft + arrowEle.offsetWidth > this.tooltipEle.clientWidth) {
          arrowleft = this.tooltipEle.clientWidth - arrowEle.offsetWidth;
        }

        sf.base.setStyleAttribute(arrowEle, {
          'left': arrowleft.toString() + 'px'
        });
      }

      sf.base.setStyleAttribute(this.tooltipEle, {
        'display': ''
      });
      eleOffset.left = left;
      return eleOffset;
    };

    SfTooltip.prototype.hideTooltip = function (hideAnimation, e, targetElement) {
      var target;

      if (e) {
        target = this.properties.target ? targetElement || e.target : this.element;
      } else {
        target = document.querySelector('[data-tooltip-id= ' + this.ctrlId + '_content]');
      }

      this.tooltipEventArgs = {
        type: e ? e.type.toString() : null,
        cancel: false,
        target: this.getDomObject('target', target),
        event: e ? e : null,
        element: this.getDomObject('tooltipElement', this.tooltipEle),
        isInteracted: !sf.base.isNullOrUndefined(e),
        name: 'beforeClose',
        collidedPosition: null
      };
      this.beforeCloseTarget = target;
      this.beforeCloseAnimation = hideAnimation;
      this.isRestrictUpdate = this.element.eventList.beforeClose && !this.isHidden();
      this.element.eventList.beforeClose ? this.triggerEvent('TriggerBeforeCloseEvent', this.tooltipEventArgs) : this.beforeCloseCallBack(false);
    };

    SfTooltip.prototype.beforeCloseCallBack = function (cancel) {
      if (!cancel) {
        this.popupHide(this.beforeCloseAnimation, this.beforeCloseTarget);
      }
    };

    SfTooltip.prototype.popupHide = function (hideAnimation, target) {
      var _this = this;

      if (target) {
        this.restoreElement(target);
      }

      var closeAnimation = {
        name: hideAnimation.effect,
        duration: hideAnimation.duration,
        delay: hideAnimation.delay,
        timingFunction: 'easeIn'
      };

      if (hideAnimation.effect === 'None') {
        closeAnimation = undefined;
      }

      if (this.properties.closeDelay > 0) {
        var hide = function hide() {
          if (_this.popupObj) {
            _this.popupObj.hide(closeAnimation);
          }
        };

        setTimeout(hide, this.properties.closeDelay);
      } else {
        if (this.popupObj) {
          this.popupObj.hide(closeAnimation);
        }
      }
    };

    SfTooltip.prototype.calculateTooltipOffset = function (position) {
      var pos = {
        top: 0,
        left: 0
      };
      var tooltipEleWidth = this.tooltipEle.offsetWidth;
      var tooltipEleHeight = this.tooltipEle.offsetHeight;
      var arrowEle = this.tooltipEle.querySelector('.' + ARROW_TIP);
      var tipWidth = arrowEle ? arrowEle.offsetWidth : 0;
      var tipHeight = arrowEle ? arrowEle.offsetHeight : 0;
      var tipAdjust = this.properties.showTipPointer ? SHOW_POINTER_TIP_GAP : HIDE_POINTER_TIP_GAP;
      var tipHeightAdjust = tipHeight / 2 + POINTER_ADJUST + (this.tooltipEle.offsetHeight - this.tooltipEle.clientHeight);
      var tipWidthAdjust = tipWidth / 2 + POINTER_ADJUST + (this.tooltipEle.offsetWidth - this.tooltipEle.clientWidth);

      if (this.properties.mouseTrail) {
        tipAdjust += MOUSE_TRAIL_GAP;
      }

      switch (position) {
        case RIGHTTOP:
          pos.left += tipWidth + tipAdjust;
          pos.top -= tooltipEleHeight - tipHeightAdjust;
          break;

        case RIGHTCENTER:
          pos.left += tipWidth + tipAdjust;
          pos.top -= tooltipEleHeight / 2;
          break;

        case RIGHTBOTTOM:
          pos.left += tipWidth + tipAdjust;
          pos.top -= tipHeightAdjust;
          break;

        case BOTTOMRIGHT:
          pos.top += tipHeight + tipAdjust;
          pos.left -= tipWidthAdjust;
          break;

        case BOTTOMCENTER:
          pos.top += tipHeight + tipAdjust;
          pos.left -= tooltipEleWidth / 2;
          break;

        case BOTTOMLEFT:
          pos.top += tipHeight + tipAdjust;
          pos.left -= tooltipEleWidth - tipWidthAdjust;
          break;

        case LEFTBOTTOM:
          pos.left -= tipWidth + tooltipEleWidth + tipAdjust;
          pos.top -= tipHeightAdjust;
          break;

        case LEFTCENTER:
          pos.left -= tipWidth + tooltipEleWidth + tipAdjust;
          pos.top -= tooltipEleHeight / 2;
          break;

        case LEFTTOP:
          pos.left -= tipWidth + tooltipEleWidth + tipAdjust;
          pos.top -= tooltipEleHeight - tipHeightAdjust;
          break;

        case TOPLEFT:
          pos.top -= tooltipEleHeight + tipHeight + tipAdjust;
          pos.left -= tooltipEleWidth - tipWidthAdjust;
          break;

        case TOPRIGHT:
          pos.top -= tooltipEleHeight + tipHeight + tipAdjust;
          pos.left -= tipWidthAdjust;
          break;

        default:
          pos.top -= tooltipEleHeight + tipHeight + tipAdjust;
          pos.left -= tooltipEleWidth / 2;
          break;
      }

      pos.left += this.properties.offsetX;
      pos.top += this.properties.offsetY;
      return pos;
    };

    SfTooltip.prototype.setTipClass = function (position) {
      if (position.indexOf(RIGHT) === 0) {
        this.tipClass = TIP_LEFT;
      } else if (position.indexOf(BOTTOM) === 0) {
        this.tipClass = TIP_TOP;
      } else if (position.indexOf(LEFT) === 0) {
        this.tipClass = TIP_RIGHT;
      } else {
        this.tipClass = TIP_BOTTOM;
      }
    };

    SfTooltip.prototype.updateTipPosition = function (position) {
      var selEle = this.tooltipEle.querySelectorAll('.' + ARROW_TIP + ',.' + ARROW_TIP_OUTER + ',.' + ARROW_TIP_INNER);
      var removeList = [TIP_BOTTOM, TIP_TOP, TIP_LEFT, TIP_RIGHT];
      sf.base.removeClass(selEle, removeList);
      this.setTipClass(position);
      sf.base.addClass(selEle, this.tipClass);
    };

    SfTooltip.prototype.adjustArrow = function (target, position, tooltipPositionX, tooltipPositionY) {
      if (this.properties.showTipPointer === false) {
        return;
      }

      this.updateTipPosition(position);
      var leftValue;
      var topValue;
      sf.base.setStyleAttribute(this.tooltipEle, {
        'display': 'block'
      });
      var tooltipWidth = this.tooltipEle.clientWidth;
      var tooltipHeight = this.tooltipEle.clientHeight;
      var arrowEle = this.tooltipEle.querySelector('.' + ARROW_TIP);
      var arrowInnerELe = this.tooltipEle.querySelector('.' + ARROW_TIP_INNER);
      var tipWidth = arrowEle.offsetWidth;
      var tipHeight = arrowEle.offsetHeight;
      sf.base.setStyleAttribute(this.tooltipEle, {
        'display': ''
      });

      if (this.tipClass === TIP_BOTTOM || this.tipClass === TIP_TOP) {
        if (this.tipClass === TIP_BOTTOM) {
          topValue = '99.9%';
          sf.base.setStyleAttribute(arrowInnerELe, {
            'top': '-' + (tipHeight - 2) + 'px'
          });
        } else {
          topValue = -(tipHeight - 1) + 'px';
          sf.base.setStyleAttribute(arrowInnerELe, {
            'top': '-' + (tipHeight - 6) + 'px'
          });
        }

        if (target) {
          var tipPosExclude = tooltipPositionX !== 'Center' || tooltipWidth > target.offsetWidth || this.properties.mouseTrail;

          if (tipPosExclude && tooltipPositionX === 'Left' || !tipPosExclude && this.properties.tipPointerPosition === END) {
            leftValue = tooltipWidth - tipWidth - POINTER_ADJUST + 'px';
          } else if (tipPosExclude && tooltipPositionX === 'Right' || !tipPosExclude && this.properties.tipPointerPosition === START) {
            leftValue = POINTER_ADJUST + 'px';
          } else {
            leftValue = tooltipWidth / 2 - tipWidth / 2 + 'px';
          }
        }
      } else {
        if (this.tipClass === TIP_RIGHT) {
          leftValue = '99.9%';
          sf.base.setStyleAttribute(arrowInnerELe, {
            'left': '-' + (tipWidth - 2) + 'px'
          });
        } else {
          leftValue = -(tipWidth - 1) + 'px';
          sf.base.setStyleAttribute(arrowInnerELe, {
            'left': -tipWidth + (tipWidth - 2) + 'px'
          });
        }

        var tipPosExclude = tooltipPositionY !== CENTER || tooltipHeight > target.offsetHeight || this.properties.mouseTrail;

        if (tipPosExclude && tooltipPositionY === TOP || !tipPosExclude && this.properties.tipPointerPosition === END) {
          topValue = tooltipHeight - tipHeight - POINTER_ADJUST + 'px';
        } else if (tipPosExclude && tooltipPositionY === BOTTOM || !tipPosExclude && this.properties.tipPointerPosition === START) {
          topValue = POINTER_ADJUST + 'px';
        } else {
          topValue = tooltipHeight / 2 - tipHeight / 2 + 'px';
        }
      }

      sf.base.setStyleAttribute(arrowEle, {
        'top': topValue,
        'left': leftValue
      });
    };

    SfTooltip.prototype.onMouseOut = function (e) {
      var enteredElement = e.relatedTarget;

      if (enteredElement && !this.properties.mouseTrail) {
        var checkForTooltipElement = sf.base.closest(enteredElement, "." + TOOLTIP_WRAP + "." + POPUP_LIB + "." + POPUP_ROOT);

        if (checkForTooltipElement) {
          sf.base.EventHandler.add(checkForTooltipElement, 'mouseleave', this.tooltipElementMouseOut, this);
          this.unwireMouseEvents(e.target);
        } else {
          this.hideTooltip(this.properties.animation.close, e, this.findTarget());

          if (this.properties.closeDelay === 0) {
            this.clear();
          }
        }
      } else {
        this.hideTooltip(this.properties.animation.close, e, this.findTarget());
        this.clear();
      }
    };

    SfTooltip.prototype.tooltipElementMouseOut = function (e) {
      this.hideTooltip(this.properties.animation.close, e, this.findTarget());
      sf.base.EventHandler.remove(this.element, 'mouseleave', this.tooltipElementMouseOut);
      this.clear();
    };

    SfTooltip.prototype.onMouseMove = function (event) {
      var eventPageX = 0;
      var eventPageY = 0;

      if (event.type.indexOf('touch') > -1) {
        event.preventDefault();
        eventPageX = event.touches[0].pageX;
        eventPageY = event.touches[0].pageY;
      } else {
        eventPageX = event.pageX;
        eventPageY = event.pageY;
      }

      sf.base.Animation.stop(this.tooltipEle);
      sf.base.removeClass([this.tooltipEle], POPUP_CLOSE);
      sf.base.addClass([this.tooltipEle], POPUP_OPEN);
      this.adjustArrow(event.target, this.properties.position, this.tooltipPositionX, this.tooltipPositionY);
      var pos = this.calculateTooltipOffset(this.properties.position);
      var x = eventPageX + pos.left + this.properties.offsetX;
      var y = eventPageY + pos.top + this.properties.offsetY;
      var elePos = this.checkCollision(event.target, x, y);

      if (this.tooltipPositionX !== elePos.horizontal || this.tooltipPositionY !== elePos.vertical) {
        var newpos = this.properties.position.indexOf(BOTTOM) === 0 || this.properties.position.indexOf(TOP) === 0 ? elePos.vertical + elePos.horizontal : elePos.horizontal + elePos.vertical;
        elePos.position = newpos;
        this.adjustArrow(event.target, elePos.position, elePos.horizontal, elePos.vertical);
        var colpos = this.calculateTooltipOffset(elePos.position);
        elePos.left = eventPageX + colpos.left - this.properties.offsetX;
        elePos.top = eventPageY + colpos.top - this.properties.offsetY;
      }

      sf.base.setStyleAttribute(this.tooltipEle, {
        'left': elePos.left + 'px',
        'top': elePos.top + 'px'
      });
    };

    SfTooltip.prototype.keyDown = function (event) {
      if (this.tooltipEle && event.keyCode === 27) {
        this.hideTooltip(this.properties.animation.close);
      }
    };

    SfTooltip.prototype.touchEnd = function (e) {
      if (this.tooltipEle && sf.base.closest(e.target, '.' + ROOT) === null) {
        this.hideTooltip(this.properties.animation.close);
      }
    };

    SfTooltip.prototype.scrollHandler = function (e) {
      if (this.tooltipEle) {
        if (!sf.base.closest(e.target, "." + TOOLTIP_WRAP + "." + POPUP_LIB + "." + POPUP_ROOT)) {
          this.hideTooltip(this.properties.animation.close);
        }
      }
    };

    SfTooltip.prototype.renderContent = function (target) {
      if (target && !sf.base.isNullOrUndefined(sf.base.getAttributeOrDefault(target, 'title', null))) {
        sf.base.attributes(target, {
          'data-content': sf.base.getAttributeOrDefault(target, 'title', null)
        });
        target.removeAttribute('title');
      }

      if (!this.properties.content) {
        var tooltipContent = this.tooltipEle.querySelector('.' + TIPCONTENT);
        tooltipContent.innerText = target.getAttribute('data-content');
      }
    };

    SfTooltip.prototype.setHeigthWidth = function (widthValue, heightValue, target) {
      if (this.tooltipEle) {
        sf.base.setStyleAttribute(this.tooltipEle, {
          'height': heightValue,
          'width': widthValue
        });
      }

      if (target && this.tooltipEle.style.width !== 'auto') {
        this.tooltipEle.style.maxWidth = widthValue;
      }
    };

    SfTooltip.prototype.contentUpdated = function () {
      if (sf.base.isNullOrUndefined(this.tooltipEle)) {
        this.ctrlId = this.element.id;
        this.tooltipEle = document.querySelector('#' + this.ctrlId + CONTENT);

        if (this.tooltipEle) {
          sf.base.setStyleAttribute(this.tooltipEle, {
            'position': 'absolute'
          });
          this.setHeigthWidth(sf.base.formatUnit(this.properties.width), sf.base.formatUnit(this.properties.height), this.contentTargetValue);

          if (this.contentTargetValue) {
            if (sf.base.Browser.isDevice) {
              sf.base.addClass([this.tooltipEle], BIGGER);
            }

            document.body.appendChild(this.tooltipEle);
            sf.base.removeClass([this.tooltipEle], HIDDDEN);
            this.addDescribedBy(this.contentTargetValue, this.ctrlId + CONTENT);
            this.renderContent(this.contentTargetValue);
            sf.base.addClass([this.tooltipEle], POPUP_OPEN);
            this.renderPopup(this.contentTargetValue);
            var pos = this.properties.position;
            this.adjustArrow(this.contentTargetValue, pos, this.tooltipPositionX, this.tooltipPositionY);
            sf.base.Animation.stop(this.tooltipEle);
            this.reposition(this.contentTargetValue);
            this.afterContentRender();
          }
        }
      } else {
        if (!this.isContiniousOpen || this.isRestrictUpdate) {
          return;
        }

        sf.base.addClass([this.tooltipEle], POPUP_OPEN);
        document.body.appendChild(this.tooltipEle);
        this.renderPopup(this.contentTargetValue);

        if (this.contentTargetValue) {
          var pos = this.properties.position;
          this.adjustArrow(this.contentTargetValue, pos, this.tooltipPositionX, this.tooltipPositionY);
          this.addDescribedBy(this.contentTargetValue, this.ctrlId + '_content');
          this.renderContent(this.contentTargetValue);
          sf.base.Animation.stop(this.tooltipEle);
          this.reposition(this.contentTargetValue);
          this.afterContentRender();
        }
      }
    };

    SfTooltip.prototype.afterContentRender = function () {
      sf.base.removeClass([this.tooltipEle], POPUP_OPEN);
      sf.base.addClass([this.tooltipEle], POPUP_CLOSE);
      this.tooltipEventArgs = {
        type: this.contentEvent ? this.contentEvent.type.toString() : null,
        isInteracted: !sf.base.isNullOrUndefined(this.contentEvent),
        target: this.getDomObject('target', this.contentTargetValue),
        name: 'beforeOpen',
        cancel: false,
        event: this.contentEvent ? this.contentEvent : null,
        element: this.getDomObject('tooltipElement', this.tooltipEle)
      };
      this.isRestrictUpdate = this.element.eventList.beforeOpen && !this.isHidden();
      this.element.eventList.beforeOpen ? this.triggerEvent('TriggerBeforeOpenEvent', this.tooltipEventArgs) : this.beforeOpenCallBack(false);
    };

    SfTooltip.prototype.beforeOpenCallBack = function (cancel) {
      var _this = this;

      if (cancel) {
        this.clear();
        this.restoreElement(this.contentTargetValue);
      } else {
        var openAnimation_1 = {
          name: this.contentAnimation.effect,
          duration: this.contentAnimation.duration,
          delay: this.contentAnimation.delay,
          timingFunction: 'easeOut'
        };

        if (this.contentAnimation.effect === 'None') {
          openAnimation_1 = undefined;
        }

        if (this.properties.openDelay > 0) {
          var show = function show() {
            if (_this.popupObj) {
              _this.popupObj.show(openAnimation_1, _this.contentTargetValue);
            }
          };

          setTimeout(show, this.properties.openDelay);
        } else {
          if (this.popupObj) {
            this.popupObj.show(openAnimation_1, this.contentTargetValue);
          }
        }
      }

      if (this.contentEvent) {
        this.wireMouseEvents(this.contentEvent, this.contentTargetValue);
      }

      this.contentTargetValue = this.contentEvent = this.contentAnimation = null;
    };

    SfTooltip.prototype.reposition = function (target) {
      if (!this.tooltipEle) {
        return;
      }

      var elePos = this.getTooltipPosition(target);
      this.popupObj.position = {
        X: elePos.left,
        Y: elePos.top
      };
      this.popupObj.dataBind();
    };

    SfTooltip.prototype.renderPopup = function (target) {
      var elePos = this.properties.mouseTrail ? {
        top: 0,
        left: 0
      } : this.getTooltipPosition(target);
      this.tooltipEle.classList.remove(POPUP_LIB);
      this.popupObj = new Popup(this.tooltipEle, {
        height: this.properties.height,
        width: this.properties.width,
        position: {
          X: elePos.left,
          Y: elePos.top
        },
        enableRtl: this.properties.enableRtl,
        open: this.openPopupHandler.bind(this),
        close: this.closePopupHandler.bind(this)
      });
    };

    SfTooltip.prototype.openPopupHandler = function () {
      if (!this.properties.mouseTrail) {
        this.reposition(this.findTarget());
      }

      this.tooltipEventArgs.name = 'Opened';
      this.isRestrictUpdate = this.element.eventList.opened && !this.isHidden();

      if (this.element.eventList.opened) {
        this.triggerEvent('TriggerOpenedEvent', this.tooltipEventArgs);
      }
    };

    SfTooltip.prototype.closePopupHandler = function () {
      this.clear();
      this.tooltipEventArgs.name = 'Closed';
      this.isRestrictUpdate = this.element.eventList.closed && !this.isHidden();

      if (this.element.eventList.closed) {
        this.triggerEvent('TriggerClosedEvent', this.tooltipEventArgs);
      }
    };

    SfTooltip.prototype.getTooltipPosition = function (target) {
      sf.base.setStyleAttribute(this.tooltipEle, {
        'display': 'block'
      });
      var pos = calculatePosition(target, this.tooltipPositionX, this.tooltipPositionY);
      var offsetPos = this.calculateTooltipOffset(this.properties.position);
      var elePos = this.collisionFlipFit(target, pos.left + offsetPos.left, pos.top + offsetPos.top);
      sf.base.setStyleAttribute(this.tooltipEle, {
        'display': ''
      });
      return elePos;
    };

    SfTooltip.prototype.getDomObject = function (value, element) {
      // tslint:disable-next-line
      return element ? window.sfBlazor.getDomObject(value, element) : null;
    };

    SfTooltip.prototype.destroy = function () {
      if (this.tooltipEle) {
        var placeholder = document.querySelector('#' + this.ctrlId + PLACEHOLDER);

        if (placeholder) {
          placeholder.appendChild(this.tooltipEle);
        }
      }

      if (this.popupObj) {
        this.popupObj.destroy();
      }

      sf.base.removeClass([this.element], ROOT);
      this.unwireEvents(this.properties.opensOn);
      this.unwireMouseEvents(this.element);
      this.tooltipEle = null;
      this.popupObj = null;
    };

    return SfTooltip;
  }(); // tslint:disable-next-line


  var Tooltip = {
    wireEvents: function wireEvents(element, dotnetRef, properties, eventList) {
      this.updateAnimation(properties.animation);
      new SfTooltip(element, dotnetRef, properties, eventList);
      element.blazor__instance.formatPosition();
      element.blazor__instance.wireEvents(properties.opensOn); // tslint:disable-next-line

      window.sfBlazor.renderComplete(element);
    },
    contentUpdated: function contentUpdated(element) {
      element.blazor__instance.contentUpdated();
    },
    updateAnimation: function updateAnimation(animation) {
      animation.open.duration = animation.open.duration ? animation.open.duration : undefined;
      animation.close.duration = animation.close.duration ? animation.close.duration : undefined;
    },
    beforeRenderCallBack: function beforeRenderCallBack(element, cancel) {
      element.blazor__instance.beforeRenderCallBack(cancel);
    },
    beforeOpenCallBack: function beforeOpenCallBack(element, cancel) {
      element.blazor__instance.beforeOpenCallBack(cancel);
    },
    beforeCloseCallBack: function beforeCloseCallBack(element, cancel) {
      element.blazor__instance.beforeCloseCallBack(cancel);
    },
    showTooltip: function showTooltip(element, target, animation, targetProp) {
      if (targetProp !== null && targetProp !== '' && element.blazor__instance.element.querySelector(targetProp)) {
        target = element.blazor__instance.element.querySelector(targetProp);
      }

      element.blazor__instance.showTooltip(target, animation, null);
    },
    hideTooltip: function hideTooltip(element, animation) {
      element.blazor__instance.hideTooltip(animation);
    },
    destroy: function destroy(element) {
      element.blazor__instance.destroy();
    },
    updateProperties: function updateProperties(element, completeProps, props) {
      var blazInstance = element.blazor__instance;
      var prevBlazProp = element.blazor__instance.properties;
      blazInstance.isRestrictUpdate = true;

      if (props.animation) {
        this.updateAnimation(props.animation);
      }

      this.updateAnimation(completeProps.animation);

      if (props.opensOn || !sf.base.isNullOrUndefined(props.isSticky)) {
        blazInstance.unwireEvents(blazInstance.properties.opensOn);
        blazInstance.properties = completeProps;
        blazInstance.wireEvents(blazInstance.properties.opensOn);
      } else {
        var target = blazInstance.findTarget();

        if (props.height || props.width) {
          blazInstance.setHeigthWidth(sf.base.formatUnit(props.width), sf.base.formatUnit(props.height), target);
        } else if (props.position) {
          blazInstance.isPositionUpdate = true;
        } else if (props.offsetX) {
          blazInstance.isOffsetXUpdate = true;
        } else if (props.offsetX) {
          blazInstance.isOffsetYUpdate = true;
        }

        if (blazInstance.tooltipEle) {
          if (blazInstance.isPositionUpdate) {
            var arrowInnerELe = blazInstance.tooltipEle.querySelector('.' + ARROW_TIP_INNER);
            var arrowEle = blazInstance.tooltipEle.querySelector('.' + ARROW_TIP);
            sf.base.removeClass([arrowEle], [blazInstance.tipClass]);
            blazInstance.properties = completeProps;
            blazInstance.formatPosition();
            blazInstance.setTipClass(props.position);
            sf.base.addClass([arrowEle], [blazInstance.tipClass]);
            sf.base.setStyleAttribute(arrowInnerELe, {
              'top': null,
              'left': null
            });
          }

          if (blazInstance.isOffsetXUpdate) {
            var value = parseInt(blazInstance.tooltipEle.style.left, 10) + (props.offsetX - prevBlazProp.offsetX);
            sf.base.setStyleAttribute(blazInstance.tooltipEle, {
              'left': value.toString() + 'px'
            });
          }

          if (blazInstance.isOffsetYUpdate) {
            var value = parseInt(blazInstance.tooltipEle.style.top, 10) + (props.offsetY - prevBlazProp.offsetY);
            sf.base.setStyleAttribute(blazInstance.tooltipEle, {
              'top': value.toString() + 'px'
            });
          }

          blazInstance.properties = completeProps;
          blazInstance.reposition(target);
        } else {
          blazInstance.properties = completeProps;

          if (blazInstance.isPositionUpdate) {
            blazInstance.formatPosition();
          }
        }

        blazInstance.isOffsetYUpdate = false;
        blazInstance.isOffsetXUpdate = false;
        blazInstance.isPositionUpdate = false;
        blazInstance.isRestrictUpdate = false;
      }
    }
  };
  return Tooltip;
}();

/***/ })

}]);