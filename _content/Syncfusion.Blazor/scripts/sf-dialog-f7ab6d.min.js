(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["sf-dialog"],{

/***/ "./bundles/sf-dialog.js":
/*!******************************!*\
  !*** ./bundles/sf-dialog.js ***!
  \******************************/
/*! no exports provided */
/*! all exports used */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _modules_sf_dialog_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modules/sf-dialog.js */ "./modules/sf-dialog.js");


/***/ }),

/***/ "./modules/sf-dialog.js":
/*!******************************!*\
  !*** ./modules/sf-dialog.js ***!
  \******************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "../node_modules/@babel/runtime/helpers/typeof.js");
/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__);

window.sfBlazor = window.sfBlazor || {};

window.sfBlazor.Dialog = function () {
  'use strict';
  /**
   * Position library
   */

  var elementRect;
  var popupRect;
  var element;
  var parentDocument;
  var fixedParent = false;

  function calculateRelativeBasedPosition(anchor, element) {
    var fixedElement = false;
    var anchorPos = {
      left: 0,
      top: 0
    };
    var tempAnchor = anchor;

    if (!anchor || !element) {
      return anchorPos;
    }

    if (sf.base.isNullOrUndefined(element.offsetParent) && element.style.position === 'fixed') {
      fixedElement = true;
    }

    while ((element.offsetParent || fixedElement) && anchor && element.offsetParent !== anchor) {
      anchorPos.left += anchor.offsetLeft;
      anchorPos.top += anchor.offsetTop;
      anchor = anchor.offsetParent;
    }

    anchor = tempAnchor;

    while ((element.offsetParent || fixedElement) && anchor && element.offsetParent !== anchor) {
      anchorPos.left -= anchor.scrollLeft;
      anchorPos.top -= anchor.scrollTop;
      anchor = anchor.parentElement;
    }

    return anchorPos;
  }

  function calculatePosition(currentElement, positionX, positionY, parentElement, targetValues) {
    positionY + positionX === 'topright' ? popupRect = undefined : popupRect = targetValues;
    popupRect = targetValues;
    fixedParent = parentElement ? true : false;

    if (!currentElement) {
      return {
        left: 0,
        top: 0
      };
    }

    if (!positionX) {
      positionX = 'left';
    }

    if (!positionY) {
      positionY = 'top';
    }

    parentDocument = currentElement.ownerDocument;
    element = currentElement;
    var pos = {
      left: 0,
      top: 0
    };
    return updatePosition(positionX.toLowerCase(), positionY.toLowerCase(), pos);
  }

  function setPosx(value, pos) {
    pos.left = value;
  }

  function setPosy(value, pos) {
    pos.top = value;
  }

  function updatePosition(posX, posY, pos) {
    elementRect = element.getBoundingClientRect();

    switch (posY + posX) {
      case 'topcenter':
        setPosx(getElementHCenter(), pos);
        setPosy(getElementTop(), pos);
        break;

      case 'topright':
        setPosx(getElementRight(), pos);
        setPosy(getElementTop(), pos);
        break;

      case 'centercenter':
        setPosx(getElementHCenter(), pos);
        setPosy(getElementVCenter(), pos);
        break;

      case 'centerright':
        setPosx(getElementRight(), pos);
        setPosy(getElementVCenter(), pos);
        break;

      case 'centerleft':
        setPosx(getElementLeft(), pos);
        setPosy(getElementVCenter(), pos);
        break;

      case 'bottomcenter':
        setPosx(getElementHCenter(), pos);
        setPosy(getElementBottom(), pos);
        break;

      case 'bottomright':
        setPosx(getElementRight(), pos);
        setPosy(getElementBottom(), pos);
        break;

      case 'bottomleft':
        setPosx(getElementLeft(), pos);
        setPosy(getElementBottom(), pos);
        break;

      default:
      case 'topleft':
        setPosx(getElementLeft(), pos);
        setPosy(getElementTop(), pos);
        break;
    }

    return pos;
  }

  function getBodyScrollTop() {
    return parentDocument.documentElement.scrollTop || parentDocument.body.scrollTop;
  }

  function getBodyScrollLeft() {
    return parentDocument.documentElement.scrollLeft || parentDocument.body.scrollLeft;
  }

  function getElementBottom() {
    return fixedParent ? elementRect.bottom : elementRect.bottom + getBodyScrollTop();
  }

  function getElementVCenter() {
    return getElementTop() + elementRect.height / 2;
  }

  function getElementTop() {
    return fixedParent ? elementRect.top : elementRect.top + getBodyScrollTop();
  }

  function getElementLeft() {
    return elementRect.left + getBodyScrollLeft();
  }

  function getElementRight() {
    return elementRect.right + getBodyScrollLeft() - (popupRect ? popupRect.width : 0);
  }

  function getElementHCenter() {
    return getElementLeft() + elementRect.width / 2;
  }
  /**
   * Collision module.
   */


  var parentDocument$1;
  var targetContainer;

  function fit(element, viewPortElement, axis, position) {
    if (viewPortElement === void 0) {
      viewPortElement = null;
    }

    if (axis === void 0) {
      axis = {
        X: false,
        Y: false
      };
    }

    if (!axis.Y && !axis.X) {
      return {
        left: 0,
        top: 0
      };
    }

    var elemData = element.getBoundingClientRect();
    targetContainer = viewPortElement;
    parentDocument$1 = element.ownerDocument;

    if (!position) {
      position = calculatePosition(element, 'left', 'top');
    }

    if (axis.X) {
      var containerWidth = targetContainer ? getTargetContainerWidth() : getViewPortWidth();
      var containerLeft = ContainerLeft();
      var containerRight = ContainerRight();
      var overLeft = containerLeft - position.left;
      var overRight = position.left + elemData.width - containerRight;

      if (elemData.width > containerWidth) {
        if (overLeft > 0 && overRight <= 0) {
          position.left = containerRight - elemData.width;
        } else if (overRight > 0 && overLeft <= 0) {
          position.left = containerLeft;
        } else {
          position.left = overLeft > overRight ? containerRight - elemData.width : containerLeft;
        }
      } else if (overLeft > 0) {
        position.left += overLeft;
      } else if (overRight > 0) {
        position.left -= overRight;
      }
    }

    if (axis.Y) {
      var containerHeight = targetContainer ? getTargetContainerHeight() : getViewPortHeight();
      var containerTop = ContainerTop();
      var containerBottom = ContainerBottom();
      var overTop = containerTop - position.top;
      var overBottom = position.top + elemData.height - containerBottom;

      if (elemData.height > containerHeight) {
        if (overTop > 0 && overBottom <= 0) {
          position.top = containerBottom - elemData.height;
        } else if (overBottom > 0 && overTop <= 0) {
          position.top = containerTop;
        } else {
          position.top = overTop > overBottom ? containerBottom - elemData.height : containerTop;
        }
      } else if (overTop > 0) {
        position.top += overTop;
      } else if (overBottom > 0) {
        position.top -= overBottom;
      }
    }

    return position;
  }

  function isCollide(element, viewPortElement, x, y) {
    if (viewPortElement === void 0) {
      viewPortElement = null;
    }

    var elemOffset = calculatePosition(element, 'left', 'top');

    if (x) {
      elemOffset.left = x;
    }

    if (y) {
      elemOffset.top = y;
    }

    var data = [];
    targetContainer = viewPortElement;
    parentDocument$1 = element.ownerDocument;
    var elementRect = element.getBoundingClientRect();
    var top = elemOffset.top;
    var left = elemOffset.left;
    var right = elemOffset.left + elementRect.width;
    var bottom = elemOffset.top + elementRect.height;
    var yAxis = topCollideCheck(top, bottom);
    var xAxis = leftCollideCheck(left, right);

    if (yAxis.topSide) {
      data.push('top');
    }

    if (xAxis.rightSide) {
      data.push('right');
    }

    if (xAxis.leftSide) {
      data.push('left');
    }

    if (yAxis.bottomSide) {
      data.push('bottom');
    }

    return data;
  }

  function flip(element, target, offsetX, offsetY, positionX, positionY, viewPortElement, axis, fixedParent) {
    if (viewPortElement === void 0) {
      viewPortElement = null;
    }

    if (axis === void 0) {
      axis = {
        X: true,
        Y: true
      };
    }

    if (!target || !element || !positionX || !positionY || !axis.X && !axis.Y) {
      return;
    }

    var tEdge = {
      TL: null,
      TR: null,
      BL: null,
      BR: null
    };
    var eEdge = {
      TL: null,
      TR: null,
      BL: null,
      BR: null
    };
    var elementRect = element.getBoundingClientRect();
    var pos = {
      posX: positionX,
      posY: positionY,
      offsetX: offsetX,
      offsetY: offsetY,
      position: {
        left: 0,
        top: 0
      }
    };
    targetContainer = viewPortElement;
    parentDocument$1 = target.ownerDocument;
    updateElementData(target, tEdge, pos, fixedParent, elementRect);
    setPosition(eEdge, pos, elementRect);

    if (axis.X) {
      leftFlip(target, eEdge, tEdge, pos, elementRect, true);
    }

    if (axis.Y && tEdge.TL.top > -1) {
      topFlip(target, eEdge, tEdge, pos, elementRect, true);
    }

    setPopup(element, pos, elementRect);
  }

  function setPopup(element, pos, elementRect) {
    var left = 0;
    var top = 0;

    if (element.offsetParent != null && (getComputedStyle(element.offsetParent).position === 'absolute' || getComputedStyle(element.offsetParent).position === 'relative')) {
      var data = calculatePosition(element.offsetParent, 'left', 'top', false, elementRect);
      left = data.left;
      top = data.top;
    }

    element.style.top = pos.position.top + pos.offsetY - top + 'px';
    element.style.left = pos.position.left + pos.offsetX - left + 'px';
  }

  function updateElementData(target, edge, pos, fixedParent, elementRect) {
    pos.position = calculatePosition(target, pos.posX, pos.posY, fixedParent, elementRect);
    edge.TL = calculatePosition(target, 'left', 'top', fixedParent, elementRect);
    edge.TR = calculatePosition(target, 'right', 'top', fixedParent, elementRect);
    edge.BR = calculatePosition(target, 'left', 'bottom', fixedParent, elementRect);
    edge.BL = calculatePosition(target, 'right', 'bottom', fixedParent, elementRect);
  }

  function setPosition(eStatus, pos, elementRect) {
    eStatus.TL = {
      top: pos.position.top + pos.offsetY,
      left: pos.position.left + pos.offsetX
    };
    eStatus.TR = {
      top: eStatus.TL.top,
      left: eStatus.TL.left + elementRect.width
    };
    eStatus.BL = {
      top: eStatus.TL.top + elementRect.height,
      left: eStatus.TL.left
    };
    eStatus.BR = {
      top: eStatus.TL.top + elementRect.height,
      left: eStatus.TL.left + elementRect.width
    };
  }

  function leftCollideCheck(left, right) {
    var leftSide = false;
    var rightSide = false;

    if (left - getBodyScrollLeft$1() < ContainerLeft()) {
      leftSide = true;
    }

    if (right > ContainerRight()) {
      rightSide = true;
    }

    return {
      leftSide: leftSide,
      rightSide: rightSide
    };
  }

  function leftFlip(target, edge, tEdge, pos, elementRect, deepCheck) {
    var collideSide = leftCollideCheck(edge.TL.left, edge.TR.left);

    if (tEdge.TL.left - getBodyScrollLeft$1() <= ContainerLeft()) {
      collideSide.leftSide = false;
    }

    if (tEdge.TR.left >= ContainerRight()) {
      collideSide.rightSide = false;
    }

    if (collideSide.leftSide && !collideSide.rightSide || !collideSide.leftSide && collideSide.rightSide) {
      if (pos.posX === 'right') {
        pos.posX = 'left';
      } else {
        pos.posX = 'right';
      }

      pos.offsetX = pos.offsetX + elementRect.width;
      pos.offsetX = -1 * pos.offsetX;
      pos.position = calculatePosition(target, pos.posX, pos.posY, false);
      setPosition(edge, pos, elementRect);

      if (deepCheck) {
        leftFlip(target, edge, tEdge, pos, elementRect, false);
      }
    }
  }

  function topFlip(target, edge, tEdge, pos, elementRect, deepCheck) {
    var collideSide = topCollideCheck(edge.TL.top, edge.BL.top);

    if (tEdge.TL.top - getBodyScrollTop$1() <= ContainerTop()) {
      collideSide.topSide = false;
    }

    if (tEdge.BL.top >= ContainerBottom()) {
      collideSide.bottomSide = false;
    }

    if (collideSide.topSide && !collideSide.bottomSide || !collideSide.topSide && collideSide.bottomSide) {
      if (pos.posY === 'top') {
        pos.posY = 'bottom';
      } else {
        pos.posY = 'top';
      }

      pos.offsetY = pos.offsetY + elementRect.height;
      pos.offsetY = -1 * pos.offsetY;
      pos.position = calculatePosition(target, pos.posX, pos.posY, false, elementRect);
      setPosition(edge, pos, elementRect);

      if (deepCheck) {
        topFlip(target, edge, tEdge, pos, elementRect, false);
      }
    }
  }

  function topCollideCheck(top, bottom) {
    var topSide = false;
    var bottomSide = false;

    if (top - getBodyScrollTop$1() < ContainerTop()) {
      topSide = true;
    }

    if (bottom > ContainerBottom()) {
      bottomSide = true;
    }

    return {
      topSide: topSide,
      bottomSide: bottomSide
    };
  }

  function getTargetContainerWidth() {
    return targetContainer.getBoundingClientRect().width;
  }

  function getTargetContainerHeight() {
    return targetContainer.getBoundingClientRect().height;
  }

  function getTargetContainerLeft() {
    return targetContainer.getBoundingClientRect().left;
  }

  function getTargetContainerTop() {
    return targetContainer.getBoundingClientRect().top;
  }

  function ContainerTop() {
    if (targetContainer) {
      return getTargetContainerTop();
    }

    return 0;
  }

  function ContainerLeft() {
    if (targetContainer) {
      return getTargetContainerLeft();
    }

    return 0;
  }

  function ContainerRight() {
    if (targetContainer) {
      return getBodyScrollLeft$1() + getTargetContainerLeft() + getTargetContainerWidth();
    }

    return getBodyScrollLeft$1() + getViewPortWidth();
  }

  function ContainerBottom() {
    if (targetContainer) {
      return getBodyScrollTop$1() + getTargetContainerTop() + getTargetContainerHeight();
    }

    return getBodyScrollTop$1() + getViewPortHeight();
  }

  function getBodyScrollTop$1() {
    // if(targetContainer)
    //     return targetContainer.scrollTop;
    return parentDocument$1.documentElement.scrollTop || parentDocument$1.body.scrollTop;
  }

  function getBodyScrollLeft$1() {
    // if(targetContainer)
    //     return targetContainer.scrollLeft;
    return parentDocument$1.documentElement.scrollLeft || parentDocument$1.body.scrollLeft;
  }

  function getViewPortHeight() {
    return window.innerHeight;
  }

  function getViewPortWidth() {
    var windowWidth = window.innerWidth;
    var offsetWidth = sf.base.isNullOrUndefined(document.documentElement) ? 0 : document.documentElement.offsetWidth;
    return windowWidth - (windowWidth - offsetWidth);
  }

  var __extends = undefined && undefined.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if ((typeof Reflect === "undefined" ? "undefined" : _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
      if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    }
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  /**
   * Specifies the offset position values.
   */


  var PositionData =
  /** @class */
  function (_super) {
    __extends(PositionData, _super);

    function PositionData() {
      return _super !== null && _super.apply(this, arguments) || this;
    }

    __decorate([sf.base.Property('left')], PositionData.prototype, "X", void 0);

    __decorate([sf.base.Property('top')], PositionData.prototype, "Y", void 0);

    return PositionData;
  }(sf.base.ChildProperty); // don't use space in classNames


  var CLASSNAMES = {
    ROOT: 'e-popup',
    RTL: 'e-rtl',
    OPEN: 'e-popup-open',
    CLOSE: 'e-popup-close'
  };
  /**
   * Represents the Popup Component
   * ```html
   * <div id="popup" style="position:absolute;height:100px;width:100px;">
   * <div style="margin:35px 25px;">Popup Content</div></div>
   * ```
   * ```typescript
   * <script>
   *   var popupObj = new Popup();
   *   popupObj.appendTo("#popup");
   * </script>
   * ```
   */

  var Popup =
  /** @class */
  function (_super) {
    __extends(Popup, _super);

    function Popup(element, options) {
      return _super.call(this, options, element) || this;
    }
    /**
     * Called internally if any of the property value changed.
     * @private
     */


    Popup.prototype.onPropertyChanged = function (newProp, oldProp) {
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];

        switch (prop) {
          case 'width':
            sf.base.setStyleAttribute(this.element, {
              'width': sf.base.formatUnit(newProp.width)
            });
            break;

          case 'height':
            sf.base.setStyleAttribute(this.element, {
              'height': sf.base.formatUnit(newProp.height)
            });
            break;

          case 'zIndex':
            sf.base.setStyleAttribute(this.element, {
              'zIndex': newProp.zIndex
            });
            break;

          case 'enableRtl':
            this.setEnableRtl();
            break;

          case 'position':
          case 'relateTo':
            this.refreshPosition();
            break;

          case 'offsetX':
            var x = newProp.offsetX - oldProp.offsetX;
            this.element.style.left = (parseInt(this.element.style.left, 10) + x).toString() + 'px';
            break;

          case 'offsetY':
            var y = newProp.offsetY - oldProp.offsetY;
            this.element.style.top = (parseInt(this.element.style.top, 10) + y).toString() + 'px';
            break;

          case 'content':
            this.setContent();
            break;

          case 'actionOnScroll':
            if (newProp.actionOnScroll !== 'none') {
              this.wireScrollEvents();
            } else {
              this.unwireScrollEvents();
            }

            break;
        }
      }
    };
    /**
     * gets the Component module name.
     * @private
     */


    Popup.prototype.getModuleName = function () {
      return 'popup';
    };
    /**
     * gets the persisted state properties of the Component.
     */


    Popup.prototype.getPersistData = function () {
      return this.addOnPersist([]);
    };
    /**
     * To destroy the control.
     */


    Popup.prototype.destroy = function () {
      this.element.classList.remove(CLASSNAMES.ROOT, CLASSNAMES.RTL, CLASSNAMES.OPEN, CLASSNAMES.CLOSE);
      this.unwireEvents();

      _super.prototype.destroy.call(this);
    };
    /**
     * To Initialize the control rendering
     * @private
     */


    Popup.prototype.render = function () {
      this.element.classList.add(CLASSNAMES.ROOT);
      var styles = {};

      if (this.zIndex !== 1000) {
        styles.zIndex = this.zIndex;
      }

      if (this.width !== 'auto') {
        styles.width = sf.base.formatUnit(this.width);
      }

      if (this.height !== 'auto') {
        styles.height = sf.base.formatUnit(this.height);
      }

      sf.base.setStyleAttribute(this.element, styles);
      this.fixedParent = false;
      this.setEnableRtl();
      this.setContent();
    };

    Popup.prototype.wireEvents = function () {
      if (sf.base.Browser.isDevice) {
        sf.base.EventHandler.add(window, 'orientationchange', this.orientationOnChange, this);
      }

      if (this.actionOnScroll !== 'none') {
        this.wireScrollEvents();
      }
    };

    Popup.prototype.wireScrollEvents = function () {
      if (this.getRelateToElement()) {
        for (var _i = 0, _a = this.getScrollableParent(this.getRelateToElement()); _i < _a.length; _i++) {
          var parent_1 = _a[_i];
          sf.base.EventHandler.add(parent_1, 'scroll', this.scrollRefresh, this);
        }
      }
    };

    Popup.prototype.unwireEvents = function () {
      if (sf.base.Browser.isDevice) {
        sf.base.EventHandler.remove(window, 'orientationchange', this.orientationOnChange);
      }

      if (this.actionOnScroll !== 'none') {
        this.unwireScrollEvents();
      }
    };

    Popup.prototype.unwireScrollEvents = function () {
      if (this.getRelateToElement()) {
        for (var _i = 0, _a = this.getScrollableParent(this.getRelateToElement()); _i < _a.length; _i++) {
          var parent_2 = _a[_i];
          sf.base.EventHandler.remove(parent_2, 'scroll', this.scrollRefresh);
        }
      }
    };

    Popup.prototype.getRelateToElement = function () {
      var relateToElement = this.relateTo === '' || sf.base.isNullOrUndefined(this.relateTo) ? document.body : this.relateTo;
      this.setProperties({
        relateTo: relateToElement
      }, true);
      return typeof this.relateTo === 'string' ? document.querySelector(this.relateTo) : this.relateTo;
    };

    Popup.prototype.scrollRefresh = function (e) {
      if (this.actionOnScroll === 'reposition') {
        if (!(this.element.offsetParent === e.target || this.element.offsetParent && this.element.offsetParent.tagName === 'BODY' && e.target.parentElement == null)) {
          this.refreshPosition();
        }
      } else if (this.actionOnScroll === 'hide') {
        this.hide();
      }

      if (this.actionOnScroll !== 'none') {
        if (this.getRelateToElement()) {
          var targetVisible = this.isElementOnViewport(this.getRelateToElement(), e.target);

          if (!targetVisible && !this.targetInvisibleStatus) {
            this.trigger('targetExitViewport');
            this.targetInvisibleStatus = true;
          } else if (targetVisible) {
            this.targetInvisibleStatus = false;
          }
        }
      }
    };
    /**
     * This method is to get the element visibility on viewport when scroll
     * the page. This method will returns true even though 1 px of element
     * part is in visible.
     */


    Popup.prototype.isElementOnViewport = function (relateToElement, scrollElement) {
      var scrollParents = this.getScrollableParent(relateToElement);

      for (var parent_3 = 0; parent_3 < scrollParents.length; parent_3++) {
        if (this.isElementVisible(relateToElement, scrollParents[parent_3])) {
          continue;
        } else {
          return false;
        }
      }

      return true;
    };

    Popup.prototype.isElementVisible = function (relateToElement, scrollElement) {
      var rect = this.checkGetBoundingClientRect(relateToElement);

      if (!rect.height || !rect.width) {
        return false;
      }

      if (!sf.base.isNullOrUndefined(this.checkGetBoundingClientRect(scrollElement))) {
        var parent_4 = scrollElement.getBoundingClientRect();
        return !(rect.bottom < parent_4.top) && !(rect.bottom > parent_4.bottom) && !(rect.right > parent_4.right) && !(rect.left < parent_4.left);
      } else {
        var win = window;
        var windowView = {
          top: win.scrollY,
          left: win.scrollX,
          right: win.scrollX + win.outerWidth,
          bottom: win.scrollY + win.outerHeight
        };
        var off = calculatePosition(relateToElement);
        var ele = {
          top: off.top,
          left: off.left,
          right: off.left + rect.width,
          bottom: off.top + rect.height
        };
        var elementView = {
          top: windowView.bottom - ele.top,
          left: windowView.right - ele.left,
          bottom: ele.bottom - windowView.top,
          right: ele.right - windowView.left
        };
        return elementView.top > 0 && elementView.left > 0 && elementView.right > 0 && elementView.bottom > 0;
      }
    };
    /**
     * Initialize the event handler
     * @private
     */


    Popup.prototype.preRender = function () {//There is no event handler
    };

    Popup.prototype.setEnableRtl = function () {
      this.reposition();
      this.enableRtl ? this.element.classList.add(CLASSNAMES.RTL) : this.element.classList.remove(CLASSNAMES.RTL);
    };

    Popup.prototype.setContent = function () {
      if (!sf.base.isNullOrUndefined(this.content)) {
        this.element.innerHTML = '';

        if (typeof this.content === 'string') {
          this.element.textContent = this.content;
        } else {
          this.element.appendChild(this.content);
        }
      }
    };

    Popup.prototype.orientationOnChange = function () {
      var _this = this;

      setTimeout(function () {
        _this.refreshPosition();
      }, 200);
    };
    /**
     * Based on the `relative` element and `offset` values, `Popup` element position will refreshed.
     */


    Popup.prototype.refreshPosition = function (target, collision) {
      if (!sf.base.isNullOrUndefined(target)) {
        this.checkFixedParent(target);
      }

      this.reposition();

      if (!collision) {
        this.checkCollision();
      }
    };

    Popup.prototype.reposition = function () {
      var pos;
      var position;
      var relateToElement = this.getRelateToElement();

      if (typeof this.position.X === 'number' && typeof this.position.Y === 'number') {
        pos = {
          left: this.position.X,
          top: this.position.Y
        };
      } else if (typeof this.position.X === 'string' && typeof this.position.Y === 'number' || typeof this.position.X === 'number' && typeof this.position.Y === 'string') {
        var display = this.element.style.display;
        var parentDisplay = void 0;
        this.element.style.display = 'block';

        if (this.element.classList.contains('e-dlg-modal')) {
          parentDisplay = this.element.parentElement.style.display;
          this.element.parentElement.style.display = 'block';
        }

        position = this.getAnchorPosition(relateToElement, this.element, this.position, this.offsetX, this.offsetY);

        if (typeof this.position.X === 'string') {
          pos = {
            left: position.left,
            top: this.position.Y
          };
        } else {
          pos = {
            left: this.position.X,
            top: position.top
          };
        }

        this.element.style.display = display;

        if (this.element.classList.contains('e-dlg-modal')) {
          this.element.parentElement.style.display = parentDisplay;
        }
      } else if (relateToElement) {
        var display = this.element.style.display;
        this.element.style.display = 'block';
        pos = this.getAnchorPosition(relateToElement, this.element, this.position, this.offsetX, this.offsetY);
        this.element.style.display = display;
      } else {
        pos = {
          left: 0,
          top: 0
        };
      }

      if (!sf.base.isNullOrUndefined(pos)) {
        this.element.style.left = pos.left + 'px';
        this.element.style.top = pos.top + 'px';
      }
    };

    Popup.prototype.checkGetBoundingClientRect = function (ele) {
      var eleRect;

      try {
        eleRect = ele.getBoundingClientRect();
        return eleRect;
      } catch (error) {
        return null;
      }
    };

    Popup.prototype.getAnchorPosition = function (anchorEle, ele, position, offsetX, offsetY) {
      var eleRect = this.checkGetBoundingClientRect(ele);
      var anchorRect = this.checkGetBoundingClientRect(anchorEle);

      if (sf.base.isNullOrUndefined(eleRect) || sf.base.isNullOrUndefined(anchorRect)) {
        return null;
      }

      var anchor = anchorEle;
      var anchorPos = {
        left: 0,
        top: 0
      };

      if (ele.offsetParent && ele.offsetParent.tagName === 'BODY' && anchorEle.tagName === 'BODY') {
        anchorPos = calculatePosition(anchorEle);
      } else {
        if (ele.classList.contains('e-dlg-modal') && anchor.tagName !== 'BODY') {
          ele = ele.parentElement;
        }

        anchorPos = calculateRelativeBasedPosition(anchor, ele);
      }

      switch (position.X) {
        default:
        case 'left':
          break;

        case 'center':
          if (ele.classList.contains('e-dlg-modal') && anchor.tagName === 'BODY' && this.targetType === 'container') {
            anchorPos.left += window.innerWidth / 2 - eleRect.width / 2;
          } else if (this.targetType === 'container') {
            anchorPos.left += anchorRect.width / 2 - eleRect.width / 2;
          } else {
            anchorPos.left += anchorRect.width / 2;
          }

          break;

        case 'right':
          if (ele.classList.contains('e-dlg-modal') && anchor.tagName === 'BODY' && this.targetType === 'container') {
            anchorPos.left += window.innerWidth - eleRect.width;
          } else if (this.targetType === 'container') {
            anchorPos.left += anchorRect.width - eleRect.width;
          } else {
            anchorPos.left += anchorRect.width;
          }

          break;
      }

      switch (position.Y) {
        default:
        case 'top':
          break;

        case 'center':
          if (ele.classList.contains('e-dlg-modal') && anchor.tagName === 'BODY' && this.targetType === 'container') {
            anchorPos.top += window.innerHeight / 2 - eleRect.height / 2;
          } else if (this.targetType === 'container') {
            anchorPos.top += anchorRect.height / 2 - eleRect.height / 2;
          } else {
            anchorPos.top += anchorRect.height / 2;
          }

          break;

        case 'bottom':
          if (ele.classList.contains('e-dlg-modal') && anchor.tagName === 'BODY' && this.targetType === 'container') {
            anchorPos.top += window.innerHeight - eleRect.height;
          } else if (this.targetType === 'container') {
            anchorPos.top += anchorRect.height - eleRect.height;
          } else {
            anchorPos.top += anchorRect.height;
          }

          break;
      }

      anchorPos.left += offsetX;
      anchorPos.top += offsetY;
      return anchorPos;
    };

    Popup.prototype.callFlip = function (param) {
      var relateToElement = this.getRelateToElement();
      flip(this.element, relateToElement, this.offsetX, this.offsetY, this.position.X, this.position.Y, this.viewPortElement, param, this.fixedParent);
    };

    Popup.prototype.callFit = function (param) {
      if (isCollide(this.element, this.viewPortElement).length !== 0) {
        if (sf.base.isNullOrUndefined(this.viewPortElement)) {
          var data = fit(this.element, this.viewPortElement, param);

          if (param.X) {
            this.element.style.left = data.left + 'px';
          }

          if (param.Y) {
            this.element.style.top = data.top + 'px';
          }
        } else {
          var elementRect = this.checkGetBoundingClientRect(this.element);
          var viewPortRect = this.checkGetBoundingClientRect(this.viewPortElement);

          if (sf.base.isNullOrUndefined(elementRect) || sf.base.isNullOrUndefined(viewPortRect)) {
            return null;
          }

          if (param && param.Y === true) {
            if (viewPortRect.top > elementRect.top) {
              this.element.style.top = '0px';
            } else if (viewPortRect.bottom < elementRect.bottom) {
              this.element.style.top = parseInt(this.element.style.top, 10) - (elementRect.bottom - viewPortRect.bottom) + 'px';
            }
          }

          if (param && param.X === true) {
            if (viewPortRect.right < elementRect.right) {
              this.element.style.left = parseInt(this.element.style.left, 10) - (elementRect.right - viewPortRect.right) + 'px';
            } else if (viewPortRect.left > elementRect.left) {
              this.element.style.left = parseInt(this.element.style.left, 10) + (viewPortRect.left - elementRect.left) + 'px';
            }
          }
        }
      }
    };

    Popup.prototype.checkCollision = function () {
      var horz = this.collision.X;
      var vert = this.collision.Y;

      if (horz === 'none' && vert === 'none') {
        return;
      }

      if (horz === 'flip' && vert === 'flip') {
        this.callFlip({
          X: true,
          Y: true
        });
      } else if (horz === 'fit' && vert === 'fit') {
        this.callFit({
          X: true,
          Y: true
        });
      } else {
        if (horz === 'flip') {
          this.callFlip({
            X: true,
            Y: false
          });
        } else if (vert === 'flip') {
          this.callFlip({
            Y: true,
            X: false
          });
        }

        if (horz === 'fit') {
          this.callFit({
            X: true,
            Y: false
          });
        } else if (vert === 'fit') {
          this.callFit({
            X: false,
            Y: true
          });
        }
      }
    };
    /**
     * Shows the popup element from screen.
     * @param { AnimationModel | Function } collisionOrAnimationOptions? - To pass animation options or collision function.
     * @param { Function } collision? - To pass the collision function.
     * @param { HTMLElement } relativeElement? - To calculate the zIndex value dynamically.
     */


    Popup.prototype.show = function (animationOptions, relativeElement) {
      var _this = this;

      this.wireEvents();

      if (this.zIndex === 1000 || !sf.base.isNullOrUndefined(relativeElement)) {
        var zIndexElement = sf.base.isNullOrUndefined(relativeElement) ? this.element : relativeElement;
        this.zIndex = getZindexPartial(zIndexElement);
        sf.base.setStyleAttribute(this.element, {
          'zIndex': this.zIndex
        });
      }

      animationOptions = !sf.base.isNullOrUndefined(animationOptions) && _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(animationOptions) === 'object' ? animationOptions : this.showAnimation;

      if (this.collision.X !== 'none' || this.collision.Y !== 'none') {
        sf.base.removeClass([this.element], CLASSNAMES.CLOSE);
        sf.base.addClass([this.element], CLASSNAMES.OPEN);
        this.checkCollision();
        sf.base.removeClass([this.element], CLASSNAMES.OPEN);
        sf.base.addClass([this.element], CLASSNAMES.CLOSE);
      }

      if (!sf.base.isNullOrUndefined(animationOptions)) {
        animationOptions.begin = function () {
          if (!_this.isDestroyed) {
            sf.base.removeClass([_this.element], CLASSNAMES.CLOSE);
            sf.base.addClass([_this.element], CLASSNAMES.OPEN);
          }
        };

        animationOptions.end = function () {
          if (!_this.isDestroyed) {
            _this.trigger('open');
          }
        };

        new sf.base.Animation(animationOptions).animate(this.element);
      } else {
        sf.base.removeClass([this.element], CLASSNAMES.CLOSE);
        sf.base.addClass([this.element], CLASSNAMES.OPEN);
        this.trigger('open');
      }
    };
    /**
     * Hides the popup element from screen.
     * @param { AnimationModel } animationOptions? - To give the animation options.
     */


    Popup.prototype.hide = function (animationOptions) {
      var _this = this;

      animationOptions = !sf.base.isNullOrUndefined(animationOptions) && _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(animationOptions) === 'object' ? animationOptions : this.hideAnimation;

      if (!sf.base.isNullOrUndefined(animationOptions)) {
        animationOptions.end = function () {
          if (!_this.isDestroyed) {
            sf.base.removeClass([_this.element], CLASSNAMES.OPEN);
            sf.base.addClass([_this.element], CLASSNAMES.CLOSE);

            _this.trigger('close');
          }
        };

        new sf.base.Animation(animationOptions).animate(this.element);
      } else {
        sf.base.removeClass([this.element], CLASSNAMES.OPEN);
        sf.base.addClass([this.element], CLASSNAMES.CLOSE);
        this.trigger('close');
      }

      this.unwireEvents();
    };
    /**
     * Gets scrollable parent elements for the given element.
     * @param { HTMLElement } element - Specify the element to get the scrollable parents of it.
     */


    Popup.prototype.getScrollableParent = function (element) {
      this.checkFixedParent(element);
      return getScrollableParent(element, this.fixedParent);
    };

    Popup.prototype.checkFixedParent = function (element) {
      var parent = element.parentElement;

      while (parent && parent.tagName !== 'HTML') {
        var parentStyle = getComputedStyle(parent);

        if (parentStyle.position === 'fixed' && this.element.offsetParent && this.element.offsetParent.tagName === 'BODY') {
          this.element.style.position = 'fixed';
          this.fixedParent = true;
        }

        parent = parent.parentElement;

        if (sf.base.isNullOrUndefined(this.element.offsetParent) && parentStyle.position === 'fixed' && this.element.style.position === 'fixed') {
          this.fixedParent = true;
        }
      }
    };

    __decorate([sf.base.Property('auto')], Popup.prototype, "height", void 0);

    __decorate([sf.base.Property('auto')], Popup.prototype, "width", void 0);

    __decorate([sf.base.Property(null)], Popup.prototype, "content", void 0);

    __decorate([sf.base.Property('container')], Popup.prototype, "targetType", void 0);

    __decorate([sf.base.Property(null)], Popup.prototype, "viewPortElement", void 0);

    __decorate([sf.base.Property({
      X: 'none',
      Y: 'none'
    })], Popup.prototype, "collision", void 0);

    __decorate([sf.base.Property('')], Popup.prototype, "relateTo", void 0);

    __decorate([sf.base.Complex({}, PositionData)], Popup.prototype, "position", void 0);

    __decorate([sf.base.Property(0)], Popup.prototype, "offsetX", void 0);

    __decorate([sf.base.Property(0)], Popup.prototype, "offsetY", void 0);

    __decorate([sf.base.Property(1000)], Popup.prototype, "zIndex", void 0);

    __decorate([sf.base.Property(false)], Popup.prototype, "enableRtl", void 0);

    __decorate([sf.base.Property('reposition')], Popup.prototype, "actionOnScroll", void 0);

    __decorate([sf.base.Property(null)], Popup.prototype, "showAnimation", void 0);

    __decorate([sf.base.Property(null)], Popup.prototype, "hideAnimation", void 0);

    __decorate([sf.base.Event()], Popup.prototype, "open", void 0);

    __decorate([sf.base.Event()], Popup.prototype, "close", void 0);

    __decorate([sf.base.Event()], Popup.prototype, "targetExitViewport", void 0);

    Popup = __decorate([sf.base.NotifyPropertyChanges], Popup);
    return Popup;
  }(sf.base.Component);
  /**
   * Gets scrollable parent elements for the given element.
   * @param { HTMLElement } element - Specify the element to get the scrollable parents of it.
   * @private
   */


  function getScrollableParent(element, fixedParent) {
    var eleStyle = getComputedStyle(element);
    var scrollParents = [];
    var overflowRegex = /(auto|scroll)/;
    var parent = element.parentElement;

    while (parent && parent.tagName !== 'HTML') {
      var parentStyle = getComputedStyle(parent);

      if (!(eleStyle.position === 'absolute' && parentStyle.position === 'static') && overflowRegex.test(parentStyle.overflow + parentStyle.overflowY + parentStyle.overflowX)) {
        scrollParents.push(parent);
      }

      parent = parent.parentElement;
    }

    if (!fixedParent) {
      scrollParents.push(document);
    }

    return scrollParents;
  }
  /**
   * Gets the maximum z-index of the given element.
   * @param { HTMLElement } element - Specify the element to get the maximum z-index of it.
   * @private
   */


  function getZindexPartial(element) {
    // upto body traversal
    var parent = element.parentElement;
    var parentZindex = [];

    while (parent) {
      if (parent.tagName !== 'BODY') {
        var index = document.defaultView.getComputedStyle(parent, null).getPropertyValue('z-index');
        var position = document.defaultView.getComputedStyle(parent, null).getPropertyValue('position');

        if (index !== 'auto' && position !== 'static') {
          parentZindex.push(index);
        }

        parent = parent.parentElement;
      } else {
        break;
      }
    } //Body direct children element traversal


    var childrenZindex = [];

    for (var i = 0; i < document.body.children.length; i++) {
      if (!element.isEqualNode(document.body.children[i])) {
        var index = document.defaultView.getComputedStyle(document.body.children[i], null).getPropertyValue('z-index');
        var position = document.defaultView.getComputedStyle(document.body.children[i], null).getPropertyValue('position');

        if (index !== 'auto' && position !== 'static') {
          childrenZindex.push(index);
        }
      }
    }

    childrenZindex.push('999');
    var siblingsZindex = [];

    if (!sf.base.isNullOrUndefined(element.parentElement) && element.parentElement.tagName !== 'BODY') {
      var childNodes = [].slice.call(element.parentElement.children);

      for (var i = 0; i < childNodes.length; i++) {
        var index = document.defaultView.getComputedStyle(childNodes[i], null).getPropertyValue('z-index');
        var position = document.defaultView.getComputedStyle(childNodes[i], null).getPropertyValue('position');

        if (index !== 'auto' && position !== 'static') {
          siblingsZindex.push(index);
        }
      }
    }

    var finalValue = parentZindex.concat(childrenZindex, siblingsZindex);
    var currentZindexValue = Math.max.apply(Math, finalValue) + 1; // Checking the max-zindex value

    return currentZindexValue > 2147483647 ? 2147483647 : currentZindexValue;
  }
  /**
   * Gets the maximum z-index of the page.
   * @param { HTMLElement } tagName - Specify the tagName to get the maximum z-index of it.
   * @private
   */

  /**
   * Resize library
   */


  var elementClass = ['north-west', 'north', 'north-east', 'west', 'east', 'south-west', 'south', 'south-east'];
  var targetElement;
  var selectedHandler;
  var originalWidth = 0;
  var originalHeight = 0;
  var originalX = 0;
  var originalY = 0;
  var originalMouseX = 0;
  var originalMouseY = 0;
  var RESIZE_HANDLER = 'e-resize-handle';
  var FOCUSED_HANDLER = 'e-focused-handle';
  var RESTRICT_LEFT = ['e-restrict-left'];
  var RESIZE_WITHIN_VIEWPORT = 'e-resize-viewport';
  var minHeight;
  var maxHeight;
  var minWidth;
  var maxWidth;
  var containerElement;
  var resizeStart = null;
  var resize = null;
  var resizeEnd = null;
  var resizeWestWidth;
  var setLeft = true;
  var previousWidth = 0;
  var setWidth = true; // tslint:disable-next-line

  var proxy;

  function createResize(args) {
    resizeStart = args.resizeBegin;
    resize = args.resizing;
    resizeEnd = args.resizeComplete;
    targetElement = getDOMElement(args.element);
    containerElement = getDOMElement(args.boundary);
    var directions = args.direction.split(' ');

    for (var i = 0; i < directions.length; i++) {
      var resizeHandler = sf.base.createElement('div', {
        className: 'e-icons ' + RESIZE_HANDLER + ' ' + 'e-' + directions[i]
      });
      targetElement.appendChild(resizeHandler);
    }

    minHeight = args.minHeight;
    minWidth = args.minWidth;
    maxWidth = args.maxWidth;
    maxHeight = args.maxHeight;

    if (args.proxy && args.proxy.element && args.proxy.element.classList.contains('e-dialog')) {
      wireEvents(args.proxy);
    } else {
      wireEvents();
    }
  }

  function getDOMElement(element) {
    var domElement;

    if (!sf.base.isNullOrUndefined(element)) {
      if (typeof element === 'string') {
        domElement = document.querySelector(element);
      } else {
        domElement = element;
      }
    }

    return domElement;
  } // tslint:disable-next-line


  function wireEvents(args) {
    if (sf.base.isNullOrUndefined(args)) {
      args = this;
    }

    var resizers = targetElement.querySelectorAll('.' + RESIZE_HANDLER);

    for (var i = 0; i < resizers.length; i++) {
      selectedHandler = resizers[i];
      sf.base.EventHandler.add(selectedHandler, 'mousedown', onMouseDown, args);
      var eventName = sf.base.Browser.info.name === 'msie' ? 'pointerdown' : 'touchstart';
      sf.base.EventHandler.add(selectedHandler, eventName, onTouchStart, args);
    }
  }
  /* istanbul ignore next */


  function getEventType(e) {
    return e.indexOf('mouse') > -1 ? 'mouse' : 'touch';
  }
  /* istanbul ignore next */


  function onMouseDown(e) {
    e.preventDefault();
    targetElement = e.target.parentElement;
    calculateValues();
    originalMouseX = e.pageX;
    originalMouseY = e.pageY;
    e.target.classList.add(FOCUSED_HANDLER);

    if (!sf.base.isNullOrUndefined(resizeStart)) {
      proxy = this;

      if (resizeStart(e, proxy) === true) {
        return;
      }
    }

    var target = sf.base.isNullOrUndefined(containerElement) ? document : containerElement;
    sf.base.EventHandler.add(target, 'mousemove', onMouseMove, this);
    sf.base.EventHandler.add(document, 'mouseup', onMouseUp, this);

    for (var i = 0; i < RESTRICT_LEFT.length; i++) {
      if (targetElement.classList.contains(RESTRICT_LEFT[i])) {
        setLeft = false;
      } else {
        setLeft = true;
      }
    }
  }
  /* istanbul ignore next */


  function onMouseUp(e) {
    var touchMoveEvent = sf.base.Browser.info.name === 'msie' ? 'pointermove' : 'touchmove';
    var touchEndEvent = sf.base.Browser.info.name === 'msie' ? 'pointerup' : 'touchend';
    var target = sf.base.isNullOrUndefined(containerElement) ? document : containerElement;
    sf.base.EventHandler.remove(target, 'mousemove', onMouseMove);
    sf.base.EventHandler.remove(target, touchMoveEvent, onMouseMove);
    var eventName = sf.base.Browser.info.name === 'msie' ? 'pointerdown' : 'touchstart';
    sf.base.EventHandler.remove(target, eventName, onMouseMove);

    if (!sf.base.isNullOrUndefined(document.body.querySelector('.' + FOCUSED_HANDLER))) {
      document.body.querySelector('.' + FOCUSED_HANDLER).classList.remove(FOCUSED_HANDLER);
    }

    if (!sf.base.isNullOrUndefined(resizeEnd)) {
      proxy = this;
      resizeEnd(e, proxy);
    }

    sf.base.EventHandler.remove(document, 'mouseup', onMouseUp);
    sf.base.EventHandler.remove(document, touchEndEvent, onMouseUp);
  }
  /* istanbul ignore next */


  function calculateValues() {
    originalWidth = parseFloat(getComputedStyle(targetElement, null).getPropertyValue('width').replace('px', ''));
    originalHeight = parseFloat(getComputedStyle(targetElement, null).getPropertyValue('height').replace('px', ''));
    originalX = targetElement.getBoundingClientRect().left;
    originalY = targetElement.getBoundingClientRect().top;
  }
  /* istanbul ignore next */


  function onTouchStart(e) {
    targetElement = e.target.parentElement;
    calculateValues();
    var coordinates = e.touches ? e.changedTouches[0] : e;
    originalMouseX = coordinates.pageX;
    originalMouseY = coordinates.pageY;

    if (!sf.base.isNullOrUndefined(resizeStart)) {
      proxy = this;

      if (resizeStart(e, proxy) === true) {
        return;
      }
    }

    var touchMoveEvent = sf.base.Browser.info.name === 'msie' ? 'pointermove' : 'touchmove';
    var touchEndEvent = sf.base.Browser.info.name === 'msie' ? 'pointerup' : 'touchend';
    var target = sf.base.isNullOrUndefined(containerElement) ? document : containerElement;
    sf.base.EventHandler.add(target, touchMoveEvent, onMouseMove, this);
    sf.base.EventHandler.add(document, touchEndEvent, onMouseUp);
  }
  /* istanbul ignore next */


  function onMouseMove(e) {
    if (e.target.classList.contains(RESIZE_HANDLER) && e.target.classList.contains(FOCUSED_HANDLER)) {
      selectedHandler = e.target;
    } else if (!sf.base.isNullOrUndefined(document.body.querySelector('.' + FOCUSED_HANDLER))) {
      selectedHandler = document.body.querySelector('.' + FOCUSED_HANDLER);
    }

    if (!sf.base.isNullOrUndefined(selectedHandler)) {
      var resizeTowards = '';

      for (var i = 0; i < elementClass.length; i++) {
        if (selectedHandler.classList.contains('e-' + elementClass[i])) {
          resizeTowards = elementClass[i];
        }
      }

      if (!sf.base.isNullOrUndefined(resize)) {
        proxy = this;
        resize(e, proxy);
      }

      switch (resizeTowards) {
        case 'south':
          resizeSouth(e);
          break;

        case 'north':
          resizeNorth(e);
          break;

        case 'west':
          resizeWest(e);
          break;

        case 'east':
          resizeEast(e);
          break;

        case 'south-east':
          resizeSouth(e);
          resizeEast(e);
          break;

        case 'south-west':
          resizeSouth(e);
          resizeWest(e);
          break;

        case 'north-east':
          resizeNorth(e);
          resizeEast(e);
          break;

        case 'north-west':
          resizeNorth(e);
          resizeWest(e);
          break;

        default:
          break;
      }
    }
  }
  /* istanbul ignore next */


  function getClientRectValues(element) {
    return element.getBoundingClientRect();
  }
  /* istanbul ignore next */
  // tslint:disable-next-line


  function resizeSouth(e) {
    var documentHeight = document.documentElement.clientHeight;
    var calculateValue = false;
    var containerRectValues;
    var coordinates = e.touches ? e.changedTouches[0] : e;
    var currentpageY = coordinates.pageY;
    var targetRectValues = getClientRectValues(targetElement);

    if (!sf.base.isNullOrUndefined(containerElement)) {
      containerRectValues = getClientRectValues(containerElement);
    }

    if (!sf.base.isNullOrUndefined(containerElement)) {
      calculateValue = true;
    } else if (sf.base.isNullOrUndefined(containerElement) && (documentHeight - currentpageY >= 0 || targetRectValues.top < 0)) {
      calculateValue = true;
    }

    var calculatedHeight = originalHeight + (currentpageY - originalMouseY);
    calculatedHeight = calculatedHeight > minHeight ? calculatedHeight : minHeight;
    var containerTop = 0;

    if (!sf.base.isNullOrUndefined(containerElement)) {
      containerTop = containerRectValues.top;
    }

    var borderValue = sf.base.isNullOrUndefined(containerElement) ? 0 : containerElement.offsetHeight - containerElement.clientHeight;
    var topWithoutborder = targetRectValues.top - containerTop - borderValue / 2;
    topWithoutborder = topWithoutborder < 0 ? 0 : topWithoutborder;

    if (targetRectValues.top > 0 && topWithoutborder + calculatedHeight > maxHeight) {
      calculateValue = false;

      if (targetElement.classList.contains(RESIZE_WITHIN_VIEWPORT)) {
        return;
      }

      targetElement.style.height = maxHeight - parseInt(topWithoutborder.toString(), 10) + 'px';
      return;
    }

    var targetTop = 0;

    if (calculateValue) {
      if (targetRectValues.top < 0 && documentHeight + (targetRectValues.height + targetRectValues.top) > 0) {
        targetTop = targetRectValues.top;

        if (calculatedHeight + targetTop <= 30) {
          calculatedHeight = targetRectValues.height - (targetRectValues.height + targetRectValues.top) + 30;
        }
      }

      if (calculatedHeight + targetRectValues.top >= maxHeight) {
        targetElement.style.height = targetRectValues.height + (documentHeight - (targetRectValues.height + targetRectValues.top)) + 'px';
      }

      var calculatedTop = sf.base.isNullOrUndefined(containerElement) ? targetTop : topWithoutborder;

      if (calculatedHeight >= minHeight && calculatedHeight + calculatedTop <= maxHeight) {
        targetElement.style.height = calculatedHeight + 'px';
      }
    }
  }
  /* istanbul ignore next */
  // tslint:disable-next-line


  function resizeNorth(e) {
    var calculateValue = false;
    var boundaryRectValues;
    var pageY = getEventType(e.type) === 'mouse' ? e.pageY : e.touches[0].pageY;
    var targetRectValues = getClientRectValues(targetElement);

    if (!sf.base.isNullOrUndefined(containerElement)) {
      boundaryRectValues = getClientRectValues(containerElement);
    }

    if (!sf.base.isNullOrUndefined(containerElement) && targetRectValues.top - boundaryRectValues.top > 0) {
      calculateValue = true;
    } else if (sf.base.isNullOrUndefined(containerElement) && pageY > 0) {
      calculateValue = true;
    }

    var currentHeight = originalHeight - (pageY - originalMouseY);

    if (getClientRectValues(targetElement).bottom + currentHeight > maxHeight) {
      calculateValue = false;
      targetElement.style.height = maxHeight - getClientRectValues(targetElement).bottom + 'px';
    }

    if (calculateValue) {
      if (currentHeight >= minHeight && currentHeight <= maxHeight) {
        var containerTop = 0;

        if (!sf.base.isNullOrUndefined(containerElement)) {
          containerTop = boundaryRectValues.top;
        }

        var top_1 = originalY - containerTop + (pageY - originalMouseY);
        top_1 = top_1 > 0 ? top_1 : 1;
        targetElement.style.height = currentHeight + 'px';
        targetElement.style.top = top_1 + 'px';
      }
    }
  }
  /* istanbul ignore next */
  // tslint:disable-next-line


  function resizeWest(e) {
    var documentWidth = document.documentElement.clientWidth;
    var calculateValue = false;
    var rectValues;

    if (!sf.base.isNullOrUndefined(containerElement)) {
      rectValues = getClientRectValues(containerElement);
    }

    var pageX = getEventType(e.type) === 'mouse' ? e.pageX : e.touches[0].pageX;
    var targetRectValues = getClientRectValues(targetElement);
    var borderValue = sf.base.isNullOrUndefined(containerElement) ? 0 : containerElement.offsetWidth - containerElement.clientWidth;
    var left = sf.base.isNullOrUndefined(containerElement) ? 0 : rectValues.left;
    var containerWidth = sf.base.isNullOrUndefined(containerElement) ? 0 : rectValues.width;

    if (sf.base.isNullOrUndefined(resizeWestWidth)) {
      if (!sf.base.isNullOrUndefined(containerElement)) {
        resizeWestWidth = targetRectValues.left - left - borderValue / 2 + targetRectValues.width;
        resizeWestWidth = resizeWestWidth + (containerWidth - borderValue - resizeWestWidth);
      } else {
        resizeWestWidth = documentWidth;
      }
    }

    if (!sf.base.isNullOrUndefined(containerElement) && targetRectValues.left - rectValues.left + targetRectValues.width + (rectValues.right - targetRectValues.right) - borderValue <= maxWidth) {
      calculateValue = true;
    } else if (sf.base.isNullOrUndefined(containerElement) && pageX >= 0) {
      calculateValue = true;
    }

    var calculatedWidth = originalWidth - (pageX - originalMouseX);

    if (setLeft) {
      calculatedWidth = calculatedWidth > resizeWestWidth ? resizeWestWidth : calculatedWidth;
    }

    if (calculateValue) {
      if (calculatedWidth >= minWidth && calculatedWidth <= maxWidth) {
        var containerLeft = 0;

        if (!sf.base.isNullOrUndefined(containerElement)) {
          containerLeft = rectValues.left;
        }

        var left_1 = originalX - containerLeft + (pageX - originalMouseX);
        left_1 = left_1 > 0 ? left_1 : 1;

        if (calculatedWidth !== previousWidth && setWidth) {
          targetElement.style.width = calculatedWidth + 'px';
        }

        if (setLeft) {
          targetElement.style.left = left_1 + 'px';

          if (left_1 === 1) {
            setWidth = false;
          } else {
            setWidth = true;
          }
        }
      }
    }

    previousWidth = calculatedWidth;
  }
  /* istanbul ignore next */
  // tslint:disable-next-line


  function resizeEast(e) {
    var documentWidth = document.documentElement.clientWidth;
    var calculateValue = false;
    var containerRectValues;

    if (!sf.base.isNullOrUndefined(containerElement)) {
      containerRectValues = getClientRectValues(containerElement);
    }

    var coordinates = e.touches ? e.changedTouches[0] : e;
    var pageX = coordinates.pageX;
    var targetRectValues = getClientRectValues(targetElement);

    if (!sf.base.isNullOrUndefined(containerElement) && (targetRectValues.left - containerRectValues.left + targetRectValues.width < maxWidth || targetRectValues.right - containerRectValues.left > targetRectValues.width)) {
      calculateValue = true;
    } else if (sf.base.isNullOrUndefined(containerElement) && documentWidth - pageX > 0) {
      calculateValue = true;
    }

    var calculatedWidth = originalWidth + (pageX - originalMouseX);
    var containerLeft = 0;

    if (!sf.base.isNullOrUndefined(containerElement)) {
      containerLeft = containerRectValues.left;
    }

    if (targetRectValues.left - containerLeft + calculatedWidth > maxWidth) {
      calculateValue = false;

      if (targetElement.classList.contains(RESIZE_WITHIN_VIEWPORT)) {
        return;
      }

      targetElement.style.width = maxWidth - (targetRectValues.left - containerLeft) + 'px';
    }

    if (calculateValue) {
      if (calculatedWidth >= minWidth && calculatedWidth <= maxWidth) {
        targetElement.style.width = calculatedWidth + 'px';
      }
    }
  }
  /* istanbul ignore next */


  function setMinHeight(minimumHeight) {
    minHeight = minimumHeight;
  }

  function removeResize() {
    var handlers = targetElement.querySelectorAll('.' + RESIZE_HANDLER);

    for (var i = 0; i < handlers.length; i++) {
      sf.base.detach(handlers[i]);
    }
  }

  var TAB = 9;
  var ENTER = 13;
  var ESCAPE = 27;
  var BTN = 'e-btn';
  var FADE = 'e-fade';
  var ICON = 'e-icons';
  var POPUP = 'e-popup';
  var DIALOG = 'e-dialog';
  var DEVICE = 'e-device';
  var PRIMARY = 'e-primary';
  var DRAGGABLE = 'e-draggable';
  var POPUP_OPEN = 'e-popup-open';
  var DLG_TARGET = 'e-dlg-target';
  var DLG_CONTENT = 'e-dlg-content';
  var DLG_OVERLAY = 'e-dlg-overlay';
  var DLG_RESIZABLE = 'e-dlg-resizable';
  var DLG_FULLSCREEN = 'e-dlg-fullscreen';
  var FOOTER_CONTENT = 'e-footer-content';
  var SCROLL_DISABLED = 'e-scroll-disabled';
  var DLG_REF_ELEMENT = 'e-dlg-ref-element';
  var DLG_RESTRICT_LEFT = 'e-restrict-left';
  var DLG_RESIZE_HANDLE = 'e-resize-handle';
  var DLG_RESIZE_VIEWPORT = 'e-resize-viewport';
  var DLG_CLOSE_ICON_BTN = 'e-dlg-closeicon-btn';
  var DLG_HEADER_CONTENT = 'e-dlg-header-content';

  var SfDialog =
  /** @class */
  function () {
    function SfDialog(element, options, dotnetRef) {
      this.hasFocusableNode = false;
      this.element = element;
      this.dotNetRef = dotnetRef;
      this.updateContext(options);

      if (this.element) {
        this.element.blazor__instance = this;
      }
    }

    SfDialog.prototype.initialize = function () {
      this.dlgContainer = undefined;
      this.popupObj = null;
      this.calculatezIndex = this.zIndex === 1000;
      this.render();
      this.dotNetRef.invokeMethodAsync('CreatedEvent', null);

      if (this.visible) {
        this.dotNetRef.invokeMethodAsync('ShowDialog', null);
      } else {
        if (this.isModal) {
          this.dlgOverlay.style.display = 'none';
        }
      }

      this.setWidth();
      this.setMinHeight();

      if (this.enableResize) {
        this.setResize();

        if (this.animationSettings.effect === 'None') {
          this.getMinHeight();
        }
      }

      this.bindEvent(this.element);
    };

    SfDialog.prototype.updateContext = function (dlgObj) {
      sf.base.extend(this, this, dlgObj);
    };

    SfDialog.prototype.setWidth = function () {
      if (this.width === '100%') {
        this.element.style.width = '';
      } else {
        sf.base.setStyleAttribute(this.element, {
          'width': sf.base.formatUnit(this.width)
        });
      }
    };

    SfDialog.prototype.setHeight = function () {
      sf.base.setStyleAttribute(this.element, {
        'height': sf.base.formatUnit(this.height)
      });
    };

    SfDialog.prototype.setMinHeight = function () {
      if (this.minHeight !== '') {
        sf.base.setStyleAttribute(this.element, {
          'minHeight': sf.base.formatUnit(this.minHeight)
        });
      }
    };

    SfDialog.prototype.render = function () {
      var _this = this;

      this.checkPositionData();
      this.targetEle = this.getTargetEle(this.target);

      if (sf.base.Browser.isDevice) {
        sf.base.addClass([this.element], DEVICE);
      }

      if (sf.base.isNullOrUndefined(this.headerContent)) {
        this.headerContent = this.element.querySelector('.' + DLG_HEADER_CONTENT);
      }

      if (sf.base.isNullOrUndefined(this.contentEle)) {
        this.contentEle = this.element.querySelector('.' + DLG_CONTENT);
      }

      this.setMaxHeight();

      if (this.zIndex === 1000) {
        this.setzIndex(this.element, false);
      }

      if (this.allowDragging && !sf.base.isNullOrUndefined(this.headerContent)) {
        this.setAllowDragging();
      }

      if (this.isModal && sf.base.isNullOrUndefined(this.dlgContainer)) {
        this.dlgContainer = this.element.parentElement;
        this.dlgOverlay = this.element.parentElement.getElementsByClassName(DLG_OVERLAY)[0];
      }

      if (!sf.base.isNullOrUndefined(this.element.parentElement)) {
        var parentEle = this.isModal ? this.dlgContainer.parentElement : this.element.parentElement;
        this.refElement = sf.base.createElement('div', {
          className: DLG_REF_ELEMENT
        });
        parentEle.insertBefore(this.refElement, this.isModal ? this.dlgContainer : this.element);
      }

      if (!sf.base.isNullOrUndefined(this.targetEle)) {
        this.isModal ? this.targetEle.appendChild(this.dlgContainer) : this.targetEle.appendChild(this.element);
      }

      this.popupObj = new Popup(this.element, {
        height: this.height,
        width: this.width,
        zIndex: this.zIndex,
        relateTo: this.getTargetEle(this.target),
        actionOnScroll: 'none',
        enableRtl: this.enableRtl,
        open: function open() {
          if (_this.enableResize) {
            _this.resetResizeIcon();
          }

          _this.dotNetRef.invokeMethodAsync('OpenEvent', null);
        },
        close: function close() {
          if (_this.isModal) {
            sf.base.addClass([_this.dlgOverlay], FADE);
            _this.dlgContainer.style.display = 'none';
          }

          _this.hasFocusableNode = false;

          _this.dotNetRef.invokeMethodAsync('CloseEvent', _this.element.classList.toString());
        }
      });
      this.positionChange();
      this.setEnableRTL();
    };

    SfDialog.prototype.checkPositionData = function () {
      if (!sf.base.isNullOrUndefined(this.position)) {
        if (!sf.base.isNullOrUndefined(this.position.X) && typeof this.position.X !== 'number') {
          var isNumber = this.isNumberValue(this.position.X);

          if (isNumber) {
            this.position.X = parseFloat(this.position.X);
          }
        }

        if (!sf.base.isNullOrUndefined(this.position.Y) && typeof this.position.Y !== 'number') {
          var isNumber = this.isNumberValue(this.position.Y);

          if (isNumber) {
            this.position.Y = parseFloat(this.position.Y);
          }
        }
      }
    };

    SfDialog.prototype.isNumberValue = function (value) {
      return /^[-+]?\d*\.?\d+$/.test(value);
    };

    SfDialog.prototype.getTargetEle = function (target) {
      var targetEle;

      if (!sf.base.isNullOrUndefined(target) && typeof target === 'string') {
        targetEle = document.querySelector(target);
      }

      return sf.base.isNullOrUndefined(targetEle) ? document.body : targetEle;
    };

    SfDialog.prototype.setMaxHeight = function () {
      if (!this.allowMaxHeight) {
        return;
      }

      var display = this.element.style.display;
      this.element.style.display = 'none';
      this.element.style.maxHeight = !sf.base.isNullOrUndefined(this.target) && this.targetEle.offsetHeight < window.innerHeight ? this.targetEle.offsetHeight - 20 + 'px' : window.innerHeight - 20 + 'px';
      this.element.style.display = display;

      if (sf.base.Browser.isIE && this.height === 'auto' && !sf.base.isNullOrUndefined(this.contentEle) && this.element.offsetHeight < this.contentEle.offsetHeight) {
        this.element.style.height = 'inherit';
      }
    };

    SfDialog.prototype.setzIndex = function (zIndexElement, setPopupZindex) {
      this.zIndex = getZindexPartial(zIndexElement);

      if (setPopupZindex) {
        this.popupObj.zIndex = this.zIndex;
      }
    };

    SfDialog.prototype.updatezIndex = function () {
      this.popupObj.zIndex = this.zIndex;

      if (this.isModal) {
        this.setOverlayZindex(this.zIndex);
      }

      this.calculatezIndex = this.element.style.zIndex !== this.zIndex.toString() ? false : true;
    };

    SfDialog.prototype.updateTarget = function () {
      this.targetEle = this.getTargetEle(this.target);
      this.popupObj.relateTo = this.targetEle;

      if (this.dragObj) {
        this.dragObj.dragArea = this.targetEle;
      }

      this.setMaxHeight();

      if (this.isModal) {
        this.targetEle.appendChild(this.dlgContainer);
      }

      if (this.enableResize) {
        this.setResize();
      }
    };

    SfDialog.prototype.resetResizeIcon = function () {
      var dialogConHeight = this.getMinHeight();

      if (this.targetEle.offsetHeight < dialogConHeight) {
        var resizeIcon = this.element.querySelector('.' + this.resizeIconDirection);

        if (!sf.base.isNullOrUndefined(resizeIcon)) {
          resizeIcon.style.bottom = '-' + dialogConHeight.toString() + 'px';
        }
      }
    };

    SfDialog.prototype.getMouseEvtArgs = function (e) {
      return {
        altKey: e.altKey,
        button: e.button,
        buttons: e.buttons,
        clientX: e.clientX,
        clientY: e.clientY,
        ctrlKey: e.ctrlKey,
        detail: e.detail,
        metaKey: e.metaKey,
        screenX: e.screenX,
        screenY: e.screenY,
        shiftKey: e.shiftKey,
        type: e.type
      };
    };

    SfDialog.prototype.setAllowDragging = function () {
      var proxy = this;
      this.dragObj = new sf.base.Draggable(this.element, {
        clone: false,
        abort: '.' + DLG_CLOSE_ICON_BTN,
        handle: '.' + DLG_HEADER_CONTENT,
        dragStart: function dragStart(e) {
          proxy.dotNetRef.invokeMethodAsync('DragStartEvent', {
            target: {
              ID: e.target.id
            },
            event: proxy.getMouseEvtArgs(e.event)
          });
          e.bindEvents(e.dragElement);
        },
        drag: function drag(e) {
          proxy.dotNetRef.invokeMethodAsync('DragEvent', {
            target: {
              ID: e.target.id
            },
            event: proxy.getMouseEvtArgs(e.event)
          });
        },
        dragStop: function dragStop(e) {
          if (proxy.isModal) {
            if (!sf.base.isNullOrUndefined(proxy.position)) {
              proxy.dlgContainer.classList.remove('e-dlg-' + proxy.position.X + '-' + proxy.position.Y);
            }

            proxy.element.style.position = 'relative';
          }

          proxy.dotNetRef.invokeMethodAsync('DragStopEvent', {
            target: {
              ID: e.target.id
            },
            event: proxy.getMouseEvtArgs(e.event)
          });
          proxy.element.classList.remove(DLG_RESTRICT_LEFT);
        }
      });

      if (!sf.base.isNullOrUndefined(this.targetEle)) {
        this.dragObj.dragArea = this.targetEle;
      }
    };

    SfDialog.prototype.positionChange = function () {
      if (this.isModal) {
        if (!isNaN(parseFloat(this.position.X)) && !isNaN(parseFloat(this.position.Y))) {
          this.setPopupPosition();
        } else if (!isNaN(parseFloat(this.position.X)) && isNaN(parseFloat(this.position.Y)) || isNaN(parseFloat(this.position.X)) && !isNaN(parseFloat(this.position.Y))) {
          this.setPopupPosition();
        } else {
          this.element.style.top = '0px';
          this.element.style.left = '0px';
          this.dlgContainer.classList.add('e-dlg-' + this.position.X + '-' + this.position.Y);
        }
      } else {
        this.setPopupPosition();
      }
    };

    SfDialog.prototype.setPopupPosition = function () {
      this.popupObj.setProperties({
        position: {
          X: this.position.X,
          Y: this.position.Y
        }
      });
    };

    SfDialog.prototype.setEnableRTL = function () {
      if (!sf.base.isNullOrUndefined(this.element.querySelector('.' + DLG_RESIZE_HANDLE))) {
        removeResize();
        this.setResize();
      }
    };

    SfDialog.prototype.setResize = function () {
      if (this.enableResize) {
        if (!sf.base.isNullOrUndefined(this.element.querySelector('.' + ICON + '.' + DLG_RESIZE_HANDLE))) {
          return;
        }

        var computedHeight = getComputedStyle(this.element).minHeight;
        var computedWidth = getComputedStyle(this.element).minWidth;

        if (this.isModal && this.enableRtl) {
          this.element.classList.add(DLG_RESTRICT_LEFT);
        } else if (this.isModal && (this.target === document.body || this.target === 'body')) {
          this.element.classList.add(DLG_RESIZE_VIEWPORT);
        }

        createResize({
          element: this.element,
          direction: this.resizeIconDirection,
          minHeight: parseInt(computedHeight.slice(0, computedWidth.indexOf('p')), 10),
          maxHeight: this.targetEle.clientHeight,
          minWidth: parseInt(computedWidth.slice(0, computedWidth.indexOf('p')), 10),
          maxWidth: this.targetEle.clientWidth,
          boundary: this.target === document.body ? null : this.targetEle,
          resizeBegin: this.onResizeStart.bind(this),
          resizeComplete: this.onResizeComplete.bind(this),
          resizing: this.onResizing.bind(this),
          proxy: this
        });
      } else {
        removeResize();

        if (this.isModal) {
          this.element.classList.remove(DLG_RESTRICT_LEFT);
        } else {
          this.element.classList.remove(DLG_RESIZE_VIEWPORT);
        }
      }
    };

    SfDialog.prototype.getMinHeight = function () {
      var computedHeaderHeight = '0px';
      var computedFooterHeight = '0px';

      if (!sf.base.isNullOrUndefined(this.element.querySelector('.' + DLG_HEADER_CONTENT))) {
        computedHeaderHeight = getComputedStyle(this.headerContent).height;
      }

      var footerEle = sf.base.select('.' + FOOTER_CONTENT, this.element);

      if (!sf.base.isNullOrUndefined(footerEle)) {
        computedFooterHeight = getComputedStyle(footerEle).height;
      }

      var headerHeight = parseInt(computedHeaderHeight.slice(0, computedHeaderHeight.indexOf('p')), 10);
      var footerHeight = parseInt(computedFooterHeight.slice(0, computedFooterHeight.indexOf('p')), 10);
      setMinHeight(headerHeight + 30 + footerHeight);
      return headerHeight + 30 + footerHeight;
    };

    SfDialog.prototype.changePosition = function (dlgObj) {
      if (this.isModal && this.dlgContainer.classList.contains('e-dlg-' + this.position.X + '-' + this.position.Y)) {
        this.dlgContainer.classList.remove('e-dlg-' + this.position.X + '-' + this.position.Y);
      }

      this.updateContext(dlgObj);
      this.checkPositionData();
      this.positionChange();
    };

    SfDialog.prototype.setOverlayZindex = function (zIndexValue) {
      var zIndex;

      if (sf.base.isNullOrUndefined(zIndexValue)) {
        zIndex = parseInt(this.element.style.zIndex, 10) ? parseInt(this.element.style.zIndex, 10) : this.zIndex;
      } else {
        zIndex = zIndexValue;
      }

      this.dlgOverlay.style.zIndex = (zIndex - 1).toString();
      this.dlgContainer.style.zIndex = zIndex.toString();
    };

    SfDialog.prototype.focusContent = function (ele) {
      var element = this.getAutoFocusNode(ele);
      var node = !sf.base.isNullOrUndefined(element) ? element : ele;
      node.focus();
      this.hasFocusableNode = true;
    };

    SfDialog.prototype.getAutoFocusNode = function (container) {
      var node = container.querySelector('.' + DLG_CLOSE_ICON_BTN);
      var value = '[autofocus]';
      var items = container.querySelectorAll(value);
      var validNode = this.getValidFocusNode(items);
      this.primaryButtonEle = this.element.getElementsByClassName(PRIMARY)[0];

      if (!sf.base.isNullOrUndefined(validNode)) {
        node = validNode;
      } else {
        validNode = this.focusableElements(this.contentEle);

        if (!sf.base.isNullOrUndefined(validNode)) {
          return node = validNode;
        } else if (!sf.base.isNullOrUndefined(this.primaryButtonEle)) {
          return this.element.querySelector('.' + PRIMARY);
        }
      }

      return node;
    };

    SfDialog.prototype.getValidFocusNode = function (items) {
      var node;

      for (var u = 0; u < items.length; u++) {
        node = items[u];

        if ((node.clientHeight > 0 || node.tagName.toLowerCase() === 'a' && node.hasAttribute('href')) && node.tabIndex > -1 && !node.disabled && !this.disableElement(node, '[disabled],[aria-disabled="true"],[type="hidden"]')) {
          return node;
        }
      }

      return node;
    };

    SfDialog.prototype.disableElement = function (element, t) {
      var elementMatch = element ? element.matches || element.webkitMatchesSelector || element.msMatchesSelector : null;

      if (elementMatch) {
        for (; element; element = element.parentNode) {
          if (element instanceof Element && elementMatch.call(element, t)) {
            return element;
          }
        }
      }

      return null;
    };

    SfDialog.prototype.focusableElements = function (content) {
      if (!sf.base.isNullOrUndefined(content)) {
        var value = 'input,select,textarea,button,a,[contenteditable="true"],[tabindex]';
        var items = content.querySelectorAll(value);
        return this.getValidFocusNode(items);
      }

      return null;
    };

    SfDialog.prototype.getMaxHeight = function (ele) {
      return ele.style.maxHeight;
    };

    SfDialog.prototype.OnPropertyChanged = function (dlgObj, props) {
      this.updateContext(dlgObj);

      for (var _i = 0, props_1 = props; _i < props_1.length; _i++) {
        var key = props_1[_i];

        switch (key) {
          case 'width':
            this.setWidth();
            break;

          case 'height':
            this.setHeight();
            break;

          case 'minHeight':
            this.setMinHeight();
            break;

          case 'target':
            this.updateTarget();
            break;

          case 'zIndex':
            this.updatezIndex();
            break;

          case 'allowDragging':
            this.setAllowDragging();
            break;

          case 'destroyDraggable':
            this.destroyDraggable();
            break;

          case 'enableRtl':
            this.setEnableRTL();
            break;

          case 'enableResize':
            this.setResize();
            break;
        }
      }
    };

    SfDialog.prototype.fullScreen = function (enable) {
      if (enable) {
        sf.base.addClass([this.element], DLG_FULLSCREEN);
        var display = this.element.style.display;
        this.element.style.display = 'none';
        this.element.style.maxHeight = !sf.base.isNullOrUndefined(this.target) ? this.targetEle.offsetHeight + 'px' : window.innerHeight + 'px';
        this.element.style.display = display;
        sf.base.addClass([document.body], [DLG_TARGET, SCROLL_DISABLED]);

        if (this.allowDragging && !sf.base.isNullOrUndefined(this.dragObj)) {
          this.dragObj.destroy();
          this.dragObj = undefined;
        }
      } else {
        sf.base.removeClass([this.element], DLG_FULLSCREEN);
        sf.base.removeClass([document.body], [DLG_TARGET, SCROLL_DISABLED]);

        if (this.allowDragging && !sf.base.isNullOrUndefined(this.headerContent)) {
          this.setAllowDragging();
        }
      }
    };

    SfDialog.prototype.show = function (isFullScreen, maxHeight, dlgObj) {
      this.updateContext(dlgObj);

      if (!this.element.classList.contains(POPUP_OPEN) || !sf.base.isNullOrUndefined(isFullScreen)) {
        if (!sf.base.isNullOrUndefined(isFullScreen)) {
          this.fullScreen(isFullScreen);
        }

        if (this.element.style.maxHeight !== maxHeight) {
          this.allowMaxHeight = false;
          this.element.style.maxHeight = maxHeight;
        }

        this.storeActiveElement = document.activeElement;
        this.element.tabIndex = -1;

        if (this.isModal && sf.base.isNullOrUndefined(this.dlgOverlay)) {
          this.dlgOverlay = this.element.parentElement.querySelector('.' + DLG_OVERLAY);
        }

        if (this.isModal && !sf.base.isNullOrUndefined(this.dlgOverlay)) {
          this.dlgOverlay.style.display = 'block';
          this.dlgContainer.style.display = 'flex';
          sf.base.removeClass([this.dlgOverlay], FADE);

          if (!sf.base.isNullOrUndefined(this.targetEle)) {
            if (this.targetEle === document.body) {
              this.dlgContainer.style.position = 'fixed';
            } else {
              this.dlgContainer.style.position = 'absolute';
            }

            this.dlgOverlay.style.position = 'absolute';
            this.element.style.position = 'relative';
            sf.base.addClass([this.targetEle], [DLG_TARGET, SCROLL_DISABLED]);
          } else {
            sf.base.addClass([document.body], [DLG_TARGET, SCROLL_DISABLED]);
          }
        }

        var openAnimation = {
          name: this.animationSettings.effect + 'In',
          duration: this.animationSettings.duration,
          delay: this.animationSettings.delay
        };
        var zIndexElement = this.isModal ? this.element.parentElement : this.element;

        if (this.calculatezIndex) {
          this.setzIndex(zIndexElement, true);
          sf.base.setStyleAttribute(this.element, {
            'zIndex': this.zIndex
          });

          if (this.isModal) {
            this.setOverlayZindex(this.zIndex);
          }
        }

        this.animationSettings.effect === 'None' ? this.popupObj.show() : this.popupObj.show(openAnimation);
      }
    };

    SfDialog.prototype.hide = function () {
      if (this.isModal) {
        !sf.base.isNullOrUndefined(this.targetEle) ? sf.base.removeClass([this.targetEle], [DLG_TARGET, SCROLL_DISABLED]) : sf.base.removeClass([document.body], [DLG_TARGET, SCROLL_DISABLED]);
      }

      var closeAnimation = {
        name: this.animationSettings.effect + 'Out',
        duration: this.animationSettings.duration,
        delay: this.animationSettings.delay
      };
      this.animationSettings.effect === 'None' ? this.popupObj.hide() : this.popupObj.hide(closeAnimation);
    };

    SfDialog.prototype.refreshPosition = function () {
      this.popupObj.refreshPosition();
    };

    SfDialog.prototype.destroyDraggable = function () {
      if (!sf.base.isNullOrUndefined(this.dragObj)) {
        this.dragObj.destroy();
        this.dragObj = undefined;
      }
    };

    SfDialog.prototype.destroy = function (dlgObj) {
      this.updateContext(dlgObj);
      var attrs = ['role', 'aria-modal', 'aria-labelledby', 'aria-describedby', 'aria-grabbed', 'tabindex', 'style'];

      if (!sf.base.isNullOrUndefined(this.cssClass) && this.cssClass !== '') {
        var classes = this.cssClass.split(' ');
        sf.base.removeClass([this.element], classes);
      }

      if (sf.base.Browser.isDevice) {
        sf.base.removeClass([this.element], DEVICE);
      }

      sf.base.removeClass([this.getTargetEle(this.target)], [DLG_TARGET, SCROLL_DISABLED]);
      this.unBindEvent(this.element);

      if (this.element.classList.contains(DLG_FULLSCREEN)) {
        sf.base.removeClass([document.body], [DLG_TARGET, SCROLL_DISABLED]);
      }

      if (this.isModal) {
        sf.base.removeClass([!sf.base.isNullOrUndefined(this.targetEle) ? this.targetEle : document.body], SCROLL_DISABLED);
      }

      if (this.element.classList.contains(DLG_RESIZABLE)) {
        removeResize();
        this.element.classList.remove(DLG_RESIZABLE);
      }

      if (this.element.classList.contains(DRAGGABLE)) {
        this.dragObj.destroy();
        this.dragObj = undefined;
      }

      if (this.element.classList.contains(POPUP)) {
        this.popupObj.destroy();
        this.popupObj = undefined;
      }

      if (!sf.base.isNullOrUndefined(this.refElement) && !sf.base.isNullOrUndefined(this.refElement.parentElement)) {
        this.refElement.parentElement.insertBefore(this.isModal ? this.dlgContainer : this.element, this.refElement);
        sf.base.detach(this.refElement);
        this.refElement = undefined;
      }

      if (!sf.base.isNullOrUndefined(this.element.children)) {
        for (var i = 0; i < this.element.children.length; i++) {
          i = i - i;
          sf.base.detach(this.element.children[i]);
        }
      }

      for (var i = 0; i < attrs.length; i++) {
        this.element.removeAttribute(attrs[i]);
      }

      if (this.isModal) {
        sf.base.detach(this.element.nextElementSibling);
        var parent_1 = this.element.parentElement;
        parent_1.removeAttribute('class');
        parent_1.removeAttribute('style');
      }

      this.element.classList.remove(DIALOG);
    };

    SfDialog.prototype.bindEvent = function (element) {
      sf.base.EventHandler.add(element, 'keydown', this.keyDown, this);
    };

    SfDialog.prototype.unBindEvent = function (element) {
      sf.base.EventHandler.remove(element, 'keydown', this.keyDown);
    };
    /* Event handlers begin */


    SfDialog.prototype.popupCloseHandler = function () {
      var activeEle = document.activeElement;

      if (!sf.base.isNullOrUndefined(activeEle) && !sf.base.isNullOrUndefined(activeEle.blur)) {
        activeEle.blur();
      }

      if (!sf.base.isNullOrUndefined(this.storeActiveElement) && !sf.base.isNullOrUndefined(this.storeActiveElement.focus)) {
        this.storeActiveElement.focus();
      }
    };

    SfDialog.prototype.onResizeStart = function (args, dialogObj) {
      var evtArgs = this.getMouseEvtArgs(args);
      this.dotNetRef.invokeMethodAsync('ResizeStartEvent', evtArgs);
    };

    SfDialog.prototype.onResizing = function (args, dialogObj) {
      this.dotNetRef.invokeMethodAsync('ResizingEvent', this.getMouseEvtArgs(args));
    };

    SfDialog.prototype.onResizeComplete = function (args, dialogObj) {
      this.dotNetRef.invokeMethodAsync('ResizeStopEvent', this.getMouseEvtArgs(args));
    };

    SfDialog.prototype.keyDown = function (e) {
      var _this = this;

      if (e.keyCode === TAB && this.isModal) {
        var btn = void 0;
        var footer = this.element.querySelector('.' + FOOTER_CONTENT);
        var btns = footer.querySelectorAll('button');

        if (btns.length > 0) {
          btn = btns[btns.length - 1];
        }

        if (sf.base.isNullOrUndefined(btn) && footer.childNodes.length > 0) {
          var value = 'input,select,textarea,button,a,[contenteditable="true"],[tabindex]';
          var items = footer.querySelectorAll(value);
          btn = items[items.length - 1];
        }

        if (!sf.base.isNullOrUndefined(btn) && document.activeElement === btn && !e.shiftKey) {
          e.preventDefault();
          this.focusableElements(this.element).focus();
        }

        if (document.activeElement === this.focusableElements(this.element) && e.shiftKey) {
          e.preventDefault();

          if (!sf.base.isNullOrUndefined(btn)) {
            btn.focus();
          }
        }
      }

      if (e.keyCode === ESCAPE && this.closeOnEscape) {
        this.dotNetRef.invokeMethodAsync('CloseDialog', {
          altKey: e.altKey,
          ctrlKey: e.ctrlKey,
          code: e.code,
          key: e.key,
          location: e.location,
          repeat: e.repeat,
          shiftKey: e.shiftKey,
          metaKey: e.metaKey,
          type: e.type
        });
      }

      if (this.hasFocusableNode) {
        var element = document.activeElement;
        var isTagName = ['input', 'textarea'].indexOf(element.tagName.toLowerCase()) > -1;
        var isContentEdit = false;

        if (!isTagName) {
          isContentEdit = element.hasAttribute('contenteditable') && element.getAttribute('contenteditable') === 'true';
        }

        if (e.keyCode === ENTER && !e.ctrlKey && element.tagName.toLowerCase() !== 'textarea' && isTagName && !sf.base.isNullOrUndefined(this.primaryButtonEle) || e.keyCode === ENTER && e.ctrlKey && (element.tagName.toLowerCase() === 'textarea' || isContentEdit) && !sf.base.isNullOrUndefined(this.primaryButtonEle)) {
          setTimeout(function () {
            _this.element.querySelector('.' + FOOTER_CONTENT + ' button.' + BTN + '.' + PRIMARY).click();
          });
        }
      }
    };

    return SfDialog;
  }(); // tslint:disable-next-line


  var Dialog = {
    initialize: function initialize(element, options, dotnetRef) {
      if (element) {
        new SfDialog(element, options, dotnetRef);
        element.blazor__instance.initialize();
      }
    },
    getClassList: function getClassList(element) {
      return element.classList.toString();
    },
    getMaxHeight: function getMaxHeight(element) {
      if (element) {
        return element.blazor__instance.getMaxHeight(element);
      } else {
        return null;
      }
    },
    changePosition: function changePosition(dlgObj) {
      dlgObj.element.blazor__instance.changePosition(dlgObj);
    },
    focusContent: function focusContent(element) {
      element.blazor__instance.focusContent(element);
    },
    refreshPosition: function refreshPosition(element) {
      element.blazor__instance.refreshPosition();
    },
    popupCloseHandler: function popupCloseHandler(element) {
      element.blazor__instance.popupCloseHandler();
    },
    propertyChanged: function propertyChanged(dlgObj, changedProps) {
      dlgObj.element.blazor__instance.OnPropertyChanged(dlgObj, changedProps);
    },
    show: function show(isFullScreen, maxHeight, dlgObj) {
      if (dlgObj.element) {
        dlgObj.element.blazor__instance.show(isFullScreen, maxHeight, dlgObj);
      }
    },
    hide: function hide(element) {
      element.blazor__instance.hide();
    },
    destroy: function destroy(dlgObj) {
      dlgObj.element.blazor__instance.destroy(dlgObj);
    }
  };
  return Dialog;
}();

/***/ })

}]);